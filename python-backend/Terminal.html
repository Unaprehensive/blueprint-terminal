<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Revolutionary Trading Terminal v2.0</title>
    <style>
        :root {
            --bg-primary: #0a0e1a;
            --bg-secondary: #141824;
            --bg-panel: rgba(20, 24, 36, 0.95);
            --accent-primary: #00ffff;
            --accent-secondary: #ff00ff;
            --accent-tertiary: #8b5cf6;
            --text-primary: #ffffff;
            --text-secondary: #94a3b8;
            --success: #22c55e;
            --danger: #ef4444;
            --warning: #f59e0b;
            --border: rgba(139, 92, 246, 0.3);
            --shadow-glow: 0 0 20px rgba(0, 255, 255, 0.3);
            --candle-bull: #00ffff;
            --candle-bear: #ff00ff;
            --candle-wick: #ffffff;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        body {
    background: var(--bg-primary);
    color: var(--text-primary);
    height: 100vh;
    overflow: hidden;
    position: relative;
    display: grid; /* ЗАМЕНА */
    grid-template-rows: auto 1fr auto; /* Шапка (auto), Основная часть (1fr), Статус-бар (auto) */
}

        /* Animated Background */
        .bg-animation {
            position: fixed;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            z-index: -1;
            opacity: 0.05;
            background: 
                radial-gradient(circle at 20% 50%, var(--accent-primary) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, var(--accent-secondary) 0%, transparent 50%);
            animation: bgPulse 10s ease-in-out infinite;
        }

        @keyframes bgPulse {
            0%, 100% { opacity: 0.05; }
            50% { opacity: 0.1; }
        }

        /* Header */
        .header {
            background: var(--bg-panel);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--border);
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 1000;
            
        }

        .logo {
            font-size: 24px;
            font-weight: bold;
            background: linear-gradient(45deg, var(--accent-primary), var(--accent-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .header-stats {
            display: flex;
            gap: 30px;
        }
        

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stat-label {
            font-size: 11px;
            color: var(--text-secondary);
            text-transform: uppercase;
        }

        .stat-value {
            font-size: 18px;
            font-weight: bold;
            color: var(--accent-primary);
        }

       .main-container {
    display: grid; /* ЗАМЕНА */
    grid-template-columns: auto 1fr auto; /* Левый сайдбар, Торговая зона, Правая панель */
    overflow: hidden;
}

        /* Left Sidebar */
        .sidebar-left {
            width: 50px;
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px 0;
            gap: 10px;
            
        }

        .tool-btn {
            width: 36px;
            height: 36px;
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(0, 255, 255, 0.1));
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            font-size: 16px;
        }

        .tool-btn:hover {
            transform: scale(1.1);
            color: var(--accent-primary);
            border-color: var(--accent-primary);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }

        .tool-btn.active {
            background: linear-gradient(135deg, var(--accent-tertiary), var(--accent-primary));
            color: var(--text-primary);
            box-shadow: 0 0 20px var(--accent-primary);
        }

        .tool-separator {
            width: 30px;
            height: 1px;
            background: var(--border);
            margin: 5px 0;
        }

        /* Central Trading Area */
       .trading-area {
    display: flex;
    flex-direction: column;
    height: calc(100vh - 140px); /* Вычитаем высоту header и status bar */
    overflow: hidden;
}

        .chart-container {
    flex: 1 1 auto; /* Занимает все доступное пространство */
    min-height: 300px;
    display: flex;
    flex-direction: column;
    background: var(--bg-primary);
    overflow: hidden;
}
        .chart-header {
            background: var(--bg-secondary);
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }

        .symbol-selector {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .symbol-select {
            background: var(--bg-panel);
            color: var(--text-primary);
            border: 1px solid var(--border);
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
        }

        .price-display {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .current-price {
            font-size: 18px;
            font-weight: bold;
        }

        .price-change {
            font-size: 14px;
        }

        .price-up { color: var(--success); }
        .price-down { color: var(--danger); }

        .timeframe-selector {
            display: flex;
            gap: 5px;
        }

        .tf-btn {
            padding: 5px 12px;
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.3s;
            font-size: 12px;
            border-radius: 4px;
        }

        .tf-btn:hover, .tf-btn.active {
            background: var(--accent-tertiary);
            color: white;
            border-color: var(--accent-tertiary);
        }

        .chart-main {
    flex: 1;
    position: relative;
    overflow: hidden;
    background: var(--bg-primary);
}

        #tradingChart {
            width: 100%;
            height: 100%;
        }

        /* Axis resize handles */
        .axis-resize-handle {
            position: absolute;
            background: transparent;
            z-index: 50;
            transition: background 0.2s;
        }
        
        .axis-resize-handle:hover {
            background: rgba(0, 255, 255, 0.1);
        }
        
        .axis-resize-handle.y-axis {
            right: 0;
            top: 0;
            bottom: 30px;
            width: 60px;
            cursor: ns-resize;
        }
        
        .axis-resize-handle.x-axis {
            bottom: 0;
            left: 0;
            right: 60px;
            height: 30px;
            cursor: ew-resize;
        }

        /* Right Panel */
        .panel-right {
            width: 340px;
            background: var(--bg-panel);
            border-left: 1px solid var(--border);
            display: flex;
            flex-direction: column;
           
        }

        .panel-tabs {
            display: flex;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
        }

        .panel-tab {
            flex: 1;
            padding: 12px;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }

        .panel-tab.active {
            color: var(--accent-primary);
        }

        .panel-tab.active:after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
        }

       .panel-content {
    flex: 1;
    padding: 15px;
    overflow-y: auto;
    overflow-x: hidden; /* Добавить это - запретить горизонтальную прокрутку */
    max-height: calc(100vh - 140px);
    display: flex;
    flex-direction: column;
}

        .tab-section {
    display: none;
    flex: 1;
    overflow-y: auto; /* Добавить это - прокрутка внутри секции */
}

        .tab-section.active {
    display: flex;
    flex-direction: column;
}
        /* Input Groups */
        .input-group {
            margin-bottom: 20px;
        }

        .input-label {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .input-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .input-field {
            flex: 1;
            padding: 12px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s;
        }

        .input-field:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
        }

        .input-unit-toggle {
            display: flex;
            gap: 5px;
        }

        .unit-btn {
            padding: 8px 12px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            color: var(--text-secondary);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 12px;
        }

        .unit-btn.active {
            background: var(--accent-tertiary);
            color: white;
            border-color: var(--accent-tertiary);
        }

        /* Quick Amounts */
        .quick-amounts {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }

        .quick-btn {
            flex: 1;
            padding: 8px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            color: var(--text-secondary);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 12px;
        }

        .quick-btn:hover {
            background: var(--accent-tertiary);
            color: white;
            transform: translateY(-2px);
        }

        /* Risk Management Section */
        .risk-management {
            background: var(--bg-secondary);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .risk-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 24px;
            display: inline-block;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            transition: 0.4s;
            border-radius: 24px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 3px;
            bottom: 3px;
            background: var(--text-secondary);
            transition: 0.4s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background: var(--accent-tertiary);
            border-color: var(--accent-tertiary);
        }

        input:checked + .toggle-slider:before {
            transform: translateX(26px);
            background: white;
        }

        .risk-inputs {
            display: none;
            gap: 10px;
        }

        .risk-inputs.active {
            display: flex;
        }

        .risk-field {
            flex: 1;
        }

        .risk-label {
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 5px;
        }

        .risk-input {
            width: 100%;
            padding: 8px;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            border-radius: 6px;
            font-size: 14px;
        }

        .calculated-values {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid var(--border);
            font-size: 12px;
            color: var(--text-secondary);
        }

        .calc-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .calc-value {
            color: var(--accent-primary);
            font-weight: bold;
        }

        /* Trade Buttons */
        .trade-buttons {
    display: flex;
    gap: 10px;
    margin-top: auto; /* Изменить с 25px на auto - прижимает к низу */
    padding-top: 15px; /* Добавить отступ сверху */
    flex-shrink: 0; /* Не сжимать кнопки */
    width: 100%; 
}

        .btn-buy, .btn-sell {
    flex: 1;
    padding: 15px 10px; /* Изменить с 15px на 15px 10px - уменьшить боковые отступы */
    border: none;
    border-radius: 10px;
    font-size: 16px;
    font-weight: bold;
    cursor: pointer;
    text-transform: uppercase;
    letter-spacing: 1px;
    transition: all 0.3s;
    min-width: 0; /* Добавить - позволяет кнопкам сжиматься */
    overflow: hidden; /* Добавить - обрезает текст если не помещается */
}

        .btn-buy {
            background: linear-gradient(135deg, var(--success), #16a34a);
            color: white;
            box-shadow: 0 4px 15px rgba(34, 197, 94, 0.3);
        }

        .btn-sell {
            background: linear-gradient(135deg, var(--danger), #dc2626);
            color: white;
            box-shadow: 0 4px 15px rgba(239, 68, 68, 0.3);
        }

        .btn-buy:hover, .btn-sell:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(0, 0, 0, 0.3);
        }

       /* Bottom Positions Panel */
.positions-panel {
    flex: 0 0 280px; /* Фиксированная высота 280px */
    min-height: 150px;
    max-height: 60vh;
    background: var(--bg-panel);
    border-top: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

        .positions-header {
            background: var(--bg-secondary);
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border);
        }

        .positions-title {
            font-size: 14px;
            font-weight: bold;
            color: var(--text-primary);
        }

        .positions-controls {
            display: flex;
            gap: 10px;
        }

        .control-btn {
            padding: 5px 12px;
            background: var(--bg-panel);
            border: 1px solid var(--border);
            color: var(--text-secondary);
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }

        .control-btn:hover {
            background: var(--accent-tertiary);
            color: white;
            border-color: var(--accent-tertiary);
        }

      .positions-table-container {
    flex: 1;
    overflow-x: auto;
    overflow-y: auto;
}

        .positions-table {
            width: 100%;
            min-width: 1200px;
            border-collapse: collapse;
        }

        .positions-table th {
            background: var(--bg-secondary);
            padding: 10px;
            text-align: left;
            font-size: 12px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .positions-table td {
            padding: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            font-size: 13px;
        }

        .positions-table tr:hover {
            background: rgba(139, 92, 246, 0.1);
        }

        .positions-table tr.selected {
            background: rgba(0, 255, 255, 0.1);
            border-left: 3px solid var(--accent-primary);
        }

        .position-symbol {
            font-weight: bold;
            color: var(--accent-primary);
        }

        .position-type-badge {
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: bold;
        }

        .position-type-badge.buy {
            background: rgba(34, 197, 94, 0.2);
            color: var(--success);
        }

        .position-type-badge.sell {
            background: rgba(239, 68, 68, 0.2);
            color: var(--danger);
        }

        .profit-value {
            font-weight: bold;
        }

        .profit-value.positive {
            color: var(--success);
        }

        .profit-value.negative {
            color: var(--danger);
        }

        .position-actions {
            display: flex;
            gap: 5px;
        }

        .action-btn {
            padding: 4px 8px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            color: var(--text-secondary);
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.3s;
        }

        .action-btn:hover {
            background: var(--accent-tertiary);
            color: white;
        }

        /* Position Settings Dialog */
        .position-settings-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--bg-panel);
            border: 1px solid var(--accent-primary);
            border-radius: 15px;
            padding: 25px;
            z-index: 2000;
            min-width: 500px;
            display: none;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.3);
        }

        .position-settings-dialog.active {
            display: block;
        }

        .dialog-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border);
        }

        .dialog-title {
            font-size: 18px;
            font-weight: bold;
            color: var(--accent-primary);
        }

        .dialog-close {
            width: 30px;
            height: 30px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 50%;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }

        .dialog-close:hover {
            background: var(--danger);
            color: white;
        }

        .dialog-content {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .setting-section {
            background: var(--bg-secondary);
            border-radius: 10px;
            padding: 15px;
        }

        .setting-title {
            font-size: 14px;
            color: var(--accent-primary);
            margin-bottom: 10px;
        }

        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .setting-value-input {
            width: 120px;
            padding: 6px 10px;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            border-radius: 6px;
            text-align: right;
        }

        .apply-btn {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        .apply-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 255, 255, 0.4);
        }

        


        .info-row {
    display: flex;
    align-items: center;
    gap: 8px;
}

        .info-label {
            color: var(--text-secondary);
        }

        .info-value {
            color: var(--text-primary);
            font-weight: bold;
        }

        /* Drawing Tools Panel */
        .drawing-tools-panel {
            position: absolute;
            top: 60px;
            left: 60px;
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 10px;
            display: none;
            z-index: 200;
            flex-direction: column;
            gap: 10px;
        }

        .drawing-tools-panel.active {
            display: flex;
        }

        .drawing-color-picker {
            display: flex;
            gap: 5px;
        }

        .color-option {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s;
        }

        .color-option:hover {
            transform: scale(1.2);
        }

        .color-option.selected {
            box-shadow: 0 0 0 2px var(--accent-primary);
        }

        /* Text Input for Drawing */
        .text-input-overlay {
            position: absolute;
            background: var(--bg-panel);
            border: 1px solid var(--accent-primary);
            border-radius: 8px;
            padding: 10px;
            display: none;
            z-index: 300;
        }

        .text-input-overlay.active {
            display: block;
        }

        .text-input-field {
            padding: 8px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            border-radius: 6px;
            width: 200px;
        }

        /* Notification */
        .notification {
            position: fixed;
            top: 80px;
            right: 20px;
            padding: 15px 20px;
            background: var(--bg-panel);
            border: 1px solid var(--accent-primary);
            border-radius: 8px;
            box-shadow: 0 0 20px var(--accent-primary);
            z-index: 3000;
            animation: slideInRight 0.3s ease;
            max-width: 350px;
        }

        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .notification.success {
            border-color: var(--success);
            box-shadow: 0 0 20px var(--success);
        }

        .notification.error {
            border-color: var(--danger);
            box-shadow: 0 0 20px var(--danger);
        }

        /* Loader */
        .loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: none;
        }

        .loader.active {
            display: block;
        }

        .loader-ring {
            width: 60px;
            height: 60px;
            border: 3px solid transparent;
            border-top-color: var(--accent-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--accent-tertiary);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent-primary);
        }

        /* Status Bar */
        .status-bar {
            background: var(--bg-panel);
            border-top: 1px solid var(--border);
            padding: 8px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .status-dot.connected {
            background: var(--success);
        }

        .status-dot.disconnected {
            background: var(--danger);
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(34, 197, 94, 0); }
            100% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0); }
        }

        .status-info {
            display: flex;
            gap: 20px;
            font-size: 12px;
            color: var(--text-secondary);
        }

        /* Theme Variations for Candles */
        .theme-matrix {
            --candle-bull: #00ff00;
            --candle-bear: #ff0000;
            --candle-wick: #00ff00;
        }

        .theme-dark {
            --candle-bull: #4caf50;
            --candle-bear: #f44336;
            --candle-wick: #888888;
        }

        .theme-light {
            --candle-bull: #4caf50;
            --candle-bear: #f44336;
            --candle-wick: #333333;
        }

        .theme-ocean {
            --candle-bull: #00e5ff;
            --candle-bear: #ff1744;
            --candle-wick: #80deea;
        }

        .theme-sunset {
            --candle-bull: #ffeb3b;
            --candle-bear: #ff5722;
            --candle-wick: #ffa726;
        }

        .theme-neon {
            --candle-bull: #00ff00;
            --candle-bear: #ff0080;
            --candle-wick: #ff00ff;
        }

        .theme-royal {
            --candle-bull: #ffd700;
            --candle-bear: #dc143c;
            --candle-wick: #daa520;
        }
.demo-badge {
    background-color: rgba(245, 158, 11, 0.2);
    color: #f59e0b;
    padding: 4px 12px;
    border-radius: 20px;
    font-size: 14px;
    font-weight: bold;
    border: 1px solid #f59e0b;
    text-transform: uppercase;
    letter-spacing: 1px;
}
/* Styles for Positions Summary Footer */
.positions-table tfoot {
    background: var(--bg-secondary);
    font-weight: bold;
}

.summary-row td {
    border-top: 2px solid var(--accent-primary);
    padding: 12px 10px;
    font-size: 14px;
    color: var(--text-primary);
}

#totalProfit {
    font-size: 15px;
}
/* Resizable panels */
.chart-container {
    min-height: 200px;
    flex: 1;
    display: flex;
    flex-direction: column;
    background: var(--bg-primary);
}

.positions-panel {
    min-height: 150px;
    max-height: 50vh;
    height: 250px; /* Начальная высота */
    background: var(--bg-panel);
    border-top: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    resize: vertical;
    overflow: auto;
}

/* Panel Resizer */
.panel-resizer {
    height: 4px;
    background: var(--border);
    cursor: ns-resize;
    flex-shrink: 0; /* Не сжимается */
}
.panel-resizer:hover {
    background: var(--accent-primary);
}

.panel-resizer:active {
    background: var(--accent-secondary);
}
.order-type-selector {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
}

.order-type-btn {
    flex: 1;
    padding: 10px;
    background: var(--bg-secondary);
    border: 1px solid var(--border);
    color: var(--text-secondary);
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s;
    font-size: 14px;
}

.order-type-btn:hover {
    background: var(--accent-tertiary);
    color: white;
    transform: translateY(-2px);
}

.order-type-btn.active {
    background: var(--accent-tertiary);
    color: white;
    border-color: var(--accent-tertiary);
    box-shadow: 0 2px 10px rgba(139, 92, 246, 0.3);
}

.limit-price-info {
    margin-top: 10px;
    font-size: 12px;
    color: var(--text-secondary);
    text-align: center;
}

#limitPriceDistance {
    color: var(--accent-primary);
    font-weight: bold;
}

.btn-buy.limit-order {
    background: linear-gradient(135deg, #3b82f6, #2563eb);
}

.btn-sell.limit-order {
    background: linear-gradient(135deg, #f97316, #ea580c);
}
/* Positions Panel Tabs */
.positions-panel-tabs {
    display: flex;
    background: var(--bg-secondary);
    border-bottom: 1px solid var(--border);
}

.positions-panel-tab {
    padding: 10px 20px;
    background: transparent;
    border: none;
    color: var(--text-secondary);
    cursor: pointer;
    font-size: 13px;
    font-weight: bold;
    text-transform: uppercase;
    letter-spacing: 1px;
    position: relative;
    transition: all 0.3s;
}

.positions-panel-tab.active {
    color: var(--accent-primary);
}

.positions-panel-tab.active:after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 2px;
    background: var(--accent-primary);
}

.positions-panel-tab-content {
    display: none;
    flex: 1;
    overflow: hidden;
    flex-direction: column;
}

.positions-panel-tab-content.active {
    display: flex;
}

.pending-orders-badge {
    background: var(--accent-tertiary);
    color: white;
    padding: 2px 6px;
    border-radius: 10px;
    font-size: 11px;
    margin-left: 5px;
}
    </style>
</head>
<body>
    <div class="bg-animation"></div>

 <div class="header">
    <div class="logo-container" style="display: flex; align-items: center; gap: 15px;">
        <div class="logo">BluePrint (beta 1.05 )</div>
        <span id="accountMode"></span>
    </div>
    <div class="header-stats">
        <div class="stat-item">
            <span class="stat-label">Balance</span>
            <span class="stat-value" id="balance">$10,000.00</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">Equity</span>
            <span class="stat-value" id="equity">$10,000.00</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">Margin</span>
            <span class="stat-value" id="margin">$0.00</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">Free Margin</span>
            <span class="stat-value" id="freeMargin">$10,000.00</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">Margin Level</span>
            <span class="stat-value" id="marginLevel">0.00%</span>
        </div>
    </div>
    <button class="header-btn" onclick="openHistory()" style="padding: 8px 16px; background: rgba(139, 92, 246, 0.1); border: 1px solid var(--border); color: var(--accent-primary); border-radius: 8px; cursor: pointer;">
         History
    </button>
</div>

   <!-- Main Container -->
<div class="main-container">
    <!-- Left Sidebar -->
    <div class="sidebar-left">
        <button class="tool-btn active" title="Cursor" onclick="selectTool('cursor')">↖</button>
        <button class="tool-btn" title="Crosshair" onclick="selectTool('crosshair')">✚</button>
        <div class="tool-separator"></div>
        <button class="tool-btn" title="Line" onclick="selectDrawingTool('line')">╱</button>
        <button class="tool-btn" title="Horizontal Line" onclick="selectDrawingTool('horizontal')">─</button>
        <button class="tool-btn" title="Rectangle" onclick="selectDrawingTool('rectangle')">▭</button>
        <button class="tool-btn" title="Text" onclick="selectDrawingTool('text')">T</button>
        <button class="tool-btn" title="Clear All" onclick="clearAllDrawings()">🗑</button>
        <div class="tool-separator"></div>
        <button class="tool-btn" title="Indicators" onclick="toggleIndicators()" style="font-size: 12px; font-weight: bold;"></button>
        <button class="tool-btn" title="Buy Limit" onclick="startPendingOrder('buy_limit')" style="color: var(--success); font-size: 11px; font-weight: bold;">BL</button>
        <button class="tool-btn" title="Sell Limit" onclick="startPendingOrder('sell_limit')" style="color: var(--danger); font-size: 11px; font-weight: bold;">SL</button>
    </div>

        <!-- Central Trading Area -->
        <div class="trading-area">
            <!-- Chart Container -->
            <div class="chart-container">
                <div class="chart-header">
                    <div class="symbol-selector">
                        <select class="symbol-select" id="symbolSelect" onchange="changeSymbol()">
    <option value="EURUSD">EUR/USD</option>
    <option value="GBPUSD">GBP/USD</option>
    <option value="XAUUSD">XAU/USD (Gold)</option>
    <option value="BTCUSD">BTC/USD</option>
</select>
                        <div class="price-display">
                            <span class="current-price price-up" id="currentPrice">-</span>
                            <span class="price-change price-up" id="priceChange">-</span>
                        </div>
                    </div>
                    <div class="timeframe-selector">
                        <button class="tf-btn" onclick="changeTimeframe('M1')">M1</button>
                        <button class="tf-btn" onclick="changeTimeframe('M5')">M5</button>
                        <button class="tf-btn" onclick="changeTimeframe('M15')">M15</button>
                        <button class="tf-btn" onclick="changeTimeframe('M30')">M30</button>
                        <button class="tf-btn active" onclick="changeTimeframe('H1')">H1</button>
                        <button class="tf-btn" onclick="changeTimeframe('H4')">H4</button>
                        <button class="tf-btn" onclick="changeTimeframe('D1')">D1</button>
                        <button class="tf-btn" onclick="changeTimeframe('W1')">W1</button>
                        <button class="tf-btn" onclick="changeTimeframe('MN')">MN</button>
                    </div>
                </div>
                <div class="chart-main">
                    <canvas id="tradingChart"></canvas>
                    
                    <!-- Axis resize handles -->
                    <div class="axis-resize-handle y-axis" id="yAxisHandle"></div>
                    <div class="axis-resize-handle x-axis" id="xAxisHandle"></div>
                    
                    <!-- Chart Info Overlay -->
                    <div class="chart-info-overlay">
                        <div class="info-row">
                            <span class="info-label">Open:</span>
                            <span class="info-value" id="ohlcOpen">-</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">High:</span>
                            <span class="info-value" id="ohlcHigh">-</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Low:</span>
                            <span class="info-value" id="ohlcLow">-</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Close:</span>
                            <span class="info-value" id="ohlcClose">-</span>
                        </div>
                    </div>
                    
                    <!-- Drawing Tools Panel -->
                    <div class="drawing-tools-panel" id="drawingToolsPanel">
                        <div class="drawing-color-picker">
                            <div class="color-option selected" style="background: var(--accent-primary)" onclick="selectDrawingColor('var(--accent-primary)')"></div>
                            <div class="color-option" style="background: var(--success)" onclick="selectDrawingColor('var(--success)')"></div>
                            <div class="color-option" style="background: var(--danger)" onclick="selectDrawingColor('var(--danger)')"></div>
                            <div class="color-option" style="background: var(--warning)" onclick="selectDrawingColor('var(--warning)')"></div>
                            <div class="color-option" style="background: white" onclick="selectDrawingColor('white')"></div>
                        </div>
                    </div>
                    <!-- Indicators Panel -->
<div class="indicators-panel" id="indicatorsPanel" style="position: absolute; top: 60px; left: 60px; background: var(--bg-panel); border: 1px solid var(--border); border-radius: 10px; padding: 15px; display: none; z-index: 200; min-width: 250px;">
    <div style="font-size: 14px; font-weight: bold; color: var(--accent-primary); margin-bottom: 15px;">Indicators</div>
    
    <div class="indicator-item" style="padding: 10px; background: var(--bg-secondary); border-radius: 8px; margin-bottom: 10px; cursor: pointer; transition: all 0.3s;" onclick="addIndicator('bpfx')" 
         onmouseover="this.style.background='var(--accent-tertiary)'" 
         onmouseout="this.style.background='var(--bg-secondary)'">
        <div style="font-size: 13px; font-weight: bold;">BPFX Buy/Sell</div>
        <div style="font-size: 11px; color: var(--text-secondary); margin-top: 5px;">Nadaraya-Watson Envelope with signals</div>
    </div>
    
    <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--border);">
        <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 10px;">Active Indicators:</div>
        <div id="activeIndicatorsList"></div>
    </div>
</div>
<!-- Indicator iframe container -->
<div id="indicatorContainer" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10;"></div>
                    <!-- Text Input Overlay -->
                    <div class="text-input-overlay" id="textInputOverlay">
                        <input type="text" class="text-input-field" id="textInputField" placeholder="Enter text..." />
                    </div>
                    
                    <div class="loader" id="chartLoader">
                        <div class="loader-ring"></div>
                    </div>
                </div>
            </div>
<!-- Panel Resizer -->
<div class="panel-resizer" id="panelResizer"></div>
<!-- Bottom Positions Panel -->
<div class="positions-panel">
    <div class="positions-panel-tabs">
        <button class="positions-panel-tab active" onclick="switchPositionsTab('positions')">
            Open Positions
            <span id="positionsCount" class="pending-orders-badge" style="display: none;">0</span>
        </button>
        <button class="positions-panel-tab" onclick="switchPositionsTab('pending')">
            Pending Orders
            <span id="pendingOrdersCount" class="pending-orders-badge" style="display: none;">0</span>
        </button>
    </div>

    <!-- Open Positions Tab -->
    <div class="positions-panel-tab-content active" id="positions-tab">
        <div class="positions-header">
            <div class="positions-title">Open Positions</div>
            <div class="positions-controls">
                <button class="control-btn" onclick="closeAllPositions()">Close All</button>
                <button class="control-btn" onclick="closeAllProfitable()">Close Profitable</button>
                <button class="control-btn" onclick="closeAllLosing()">Close Losing</button>
            </div>
        </div>
        <div class="positions-table-container">
            <table class="positions-table">
                <thead>
                    <tr>
                        <th>Symbol</th>
                        <th>Type</th>
                        <th>Volume</th>
                        <th>Open Price</th>
                        <th>Current Price</th>
                        <th>S/L ($)</th>
                        <th>T/P ($)</th>
                        <th>Profit ($)</th>
                        <th>Trailing</th>
                        <th>Breakeven</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tfoot id="positionsTableFooter">
                    <tr class="summary-row">
                        <td colspan="2">Total:</td>
                        <td id="totalVolume">0.00</td>
                        <td colspan="4"></td>
                        <td id="totalProfit">$0.00</td>
                        <td colspan="3"></td>
                    </tr>
                </tfoot>
                <tbody id="positionsTableBody">
                    <tr>
                        <td colspan="11" style="text-align: center; color: var(--text-secondary); padding: 40px;">
                            No open positions
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>

    <!-- Pending Orders Tab -->
    <div class="positions-panel-tab-content" id="pending-tab">
        <div class="positions-header">
            <div class="positions-title">Limit Orders</div>
            <div class="positions-controls">
                <button class="control-btn" onclick="cancelAllPendingOrders()">Cancel All</button>
            </div>
        </div>
        <div class="positions-table-container">
            <table class="positions-table">
                <thead>
                    <tr>
                        <th>Ticket</th>
                        <th>Symbol</th>
                        <th>Type</th>
                        <th>Volume</th>
                        <th>Price</th>
                        <th>Distance</th>
                        <th>S/L</th>
                        <th>T/P</th>
                        <th>Time</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="pendingOrdersTableBody">
                    <tr>
                        <td colspan="10" style="text-align: center; color: var(--text-secondary); padding: 40px;">
                            No pending orders
                        </td>
                    </tr>
                </tbody>
                <tfoot id="pendingOrdersTableFooter" style="display: none;">
                    <tr class="summary-row">
                        <td colspan="3" id="totalPendingOrders">Total: 0 Orders</td>
                        <td id="totalPendingVolume">0.00</td>
                        <td colspan="6"></td>
                    </tr>
                </tfoot>
            </table>
        </div>
    </div>
</div>
</div>

<!-- Right Panel -->
        <div class="panel-right">
            <div class="panel-tabs">
                <button class="panel-tab active" onclick="switchTab('trading')">Trading</button>
                <button class="panel-tab" onclick="switchTab('settings')">Settings</button>
            </div>

            <div class="panel-content">
                <!-- Trading Tab -->
                <div class="tab-section active" id="trading-tab">
                    <!-- Risk Management Toggle -->
                    <div class="risk-management">
                        <div class="risk-toggle">
                            <label class="toggle-switch">
                                <input type="checkbox" id="riskModeToggle" onchange="toggleRiskMode()">
                                <span class="toggle-slider"></span>
                            </label>
                            <span>Risk Management Mode</span>
                        </div>
                        <div class="risk-inputs" id="riskInputs">
                            <div class="risk-field">
                                <div class="risk-label">Risk %</div>
                                <input type="number" class="risk-input" id="riskPercent" value="1" min="0.1" max="100" step="0.1">
                            </div>
                            <div class="risk-field">
                                <div class="risk-label">Reward Ratio</div>
                                <input type="number" class="risk-input" id="rewardRatio" value="3" min="0.1" max="10" step="0.1">
                            </div>
                        </div>
                        <div class="calculated-values" id="calculatedValues" style="display: none;">
                            <div class="calc-row">
                                <span>Risk Amount:</span>
                                <span class="calc-value" id="calcRiskAmount">$0.00</span>
                            </div>
                            <div class="calc-row">
                                <span>Potential Profit:</span>
                                <span class="calc-value" id="calcProfit">$0.00</span>
                            </div>
                            <div class="calc-row">
                                <span>Calculated Volume:</span>
                                <span class="calc-value" id="calcVolume">0.00</span>
                            </div>
                        </div>
                    </div>

                    <!-- Volume Input -->
                    <div class="input-group" id="volumeGroup">
                        <div class="input-label">Volume (Lots)</div>
                        <div class="input-row">
                            <input type="number" class="input-field" value="0.01" step="0.01" min="0.01" max="100" id="lotSize">
                        </div>
                        <div class="quick-amounts">
                            <button class="quick-btn" onclick="setLot(0.01)">0.01</button>
                            <button class="quick-btn" onclick="setLot(0.05)">0.05</button>
                            <button class="quick-btn" onclick="setLot(0.10)">0.10</button>
                            <button class="quick-btn" onclick="setLot(0.50)">0.50</button>
                            <button class="quick-btn" onclick="setLot(1.00)">1.00</button>
                        </div>
                    </div>

                    <!-- Stop Loss Input -->
                    <div class="input-group">
                        <div class="input-label">Stop Loss</div>
                        <div class="input-row">
                            <input type="number" class="input-field" placeholder="Optional" id="stopLoss">
                            <div class="input-unit-toggle">
                                <button class="unit-btn active" id="slUnitPips" onclick="toggleSLUnit('pips')">Pips</button>
                                <button class="unit-btn" id="slUnitDollar" onclick="toggleSLUnit('dollar')">$</button>
                            </div>
                        </div>
                    </div>

                    <!-- Take Profit Input -->
                    <div class="input-group">
                        <div class="input-label">Take Profit</div>
                        <div class="input-row">
                            <input type="number" class="input-field" placeholder="Optional" id="takeProfit">
                            <div class="input-unit-toggle">
                                <button class="unit-btn active" id="tpUnitPips" onclick="toggleTPUnit('pips')">Pips</button>
                                <button class="unit-btn" id="tpUnitDollar" onclick="toggleTPUnit('dollar')">$</button>
                            </div>
                        </div>
                    </div>

                    <!-- Order Type Selection -->
<div class="input-group">
    <div class="input-label">Order Type</div>
    <div class="order-type-selector">
        <button class="order-type-btn active" id="marketOrderBtn" onclick="selectOrderType('market')">
            Market Order
        </button>
        <button class="order-type-btn" id="limitOrderBtn" onclick="selectOrderType('limit')">
            Limit Order
        </button>
    </div>
</div>

<!-- Limit Price Input (показывается только для лимитных ордеров) -->
<div class="input-group" id="limitPriceGroup" style="display: none;">
    <div class="input-label">Limit Price</div>
    <div class="input-row">
        <input type="number" class="input-field" id="limitPrice" step="0.00001">
        <button class="quick-btn" onclick="setLimitPriceFromCurrent('bid')">Bid</button>
        <button class="quick-btn" onclick="setLimitPriceFromCurrent('ask')">Ask</button>
    </div>
    <div class="limit-price-info">
        <span id="limitPriceDistance">-</span> pips from current price
    </div>
</div>

<!-- Automation Settings -->
<div class="risk-management" style="margin-top: 15px;">
    <div class="setting-title" style="color: var(--accent-primary); margin-bottom: 10px;">Automation Settings</div>
    
    <!-- Trailing Stop -->
    <div class="risk-toggle">
        <label class="toggle-switch">
            <input type="checkbox" id="presetTrailing" onchange="togglePresetTrailing()">
            <span class="toggle-slider"></span>
        </label>
        <span>Trailing Stop</span>
    </div>
    <div class="risk-inputs" id="trailingInputs" style="display: none; margin-bottom: 10px;">
        <div class="risk-field">
            <div class="risk-label">Activation ($)</div>
            <input type="number" class="risk-input" id="presetTrailingProfit" value="10" min="1">
        </div>
        <div class="risk-field">
            <div class="risk-label">Distance ($)</div>
            <input type="number" class="risk-input" id="presetTrailingDistance" value="5" min="1">
        </div>
    </div>
    
    <!-- Breakeven -->
    <div class="risk-toggle">
        <label class="toggle-switch">
            <input type="checkbox" id="presetBreakeven" onchange="togglePresetBreakeven()">
            <span class="toggle-slider"></span>
        </label>
        <span>Auto Breakeven</span>
    </div>
    <div class="risk-inputs" id="breakevenInputs" style="display: none;">
        <div class="risk-field">
            <div class="risk-label">Activation ($)</div>
            <input type="number" class="risk-input" id="presetBreakevenProfit" value="5" min="1">
        </div>
    </div>
</div>

<!-- Обновленные кнопки Buy/Sell -->
<div class="trade-buttons">
    <button class="btn-buy" id="buyButton" onclick="executeTrade('buy')">
        <span id="buyButtonText">BUY</span><br>
        <span style="font-size: 12px; font-weight: normal;" id="buyPrice">-</span>
    </button>
    <button class="btn-sell" id="sellButton" onclick="executeTrade('sell')">
        <span id="sellButtonText">SELL</span><br>
        <span style="font-size: 12px; font-weight: normal;" id="sellPrice">-</span>
    </button>
</div>
</div>
                <!-- Settings Tab -->
                <div class="tab-section" id="settings-tab">
                    <div class="setting-group">
                        <div class="setting-title">Theme</div>
                        <div class="theme-grid" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                            <div class="theme-option active" onclick="changeTheme('cyberpunk')" style="padding: 15px; background: var(--bg-secondary); border: 2px solid var(--border); border-radius: 8px; cursor: pointer; text-align: center;">Cyberpunk</div>
                            <div class="theme-option" onclick="changeTheme('matrix')" style="padding: 15px; background: var(--bg-secondary); border: 2px solid var(--border); border-radius: 8px; cursor: pointer; text-align: center;">Matrix</div>
                            <div class="theme-option" onclick="changeTheme('dark')" style="padding: 15px; background: var(--bg-secondary); border: 2px solid var(--border); border-radius: 8px; cursor: pointer; text-align: center;">Dark</div>
                            <div class="theme-option" onclick="changeTheme('light')" style="padding: 15px; background: var(--bg-secondary); border: 2px solid var(--border); border-radius: 8px; cursor: pointer; text-align: center;">Light</div>
                            <div class="theme-option" onclick="changeTheme('ocean')" style="padding: 15px; background: var(--bg-secondary); border: 2px solid var(--border); border-radius: 8px; cursor: pointer; text-align: center;">Ocean</div>
                            <div class="theme-option" onclick="changeTheme('sunset')" style="padding: 15px; background: var(--bg-secondary); border: 2px solid var(--border); border-radius: 8px; cursor: pointer; text-align: center;">Sunset</div>
                            <div class="theme-option" onclick="changeTheme('neon')" style="padding: 15px; background: var(--bg-secondary); border: 2px solid var(--border); border-radius: 8px; cursor: pointer; text-align: center;">Neon</div>
                            <div class="theme-option" onclick="changeTheme('royal')" style="padding: 15px; background: var(--bg-secondary); border: 2px solid var(--border); border-radius: 8px; cursor: pointer; text-align: center;">Royal</div>
                        </div>
                    </div>

                    <div class="setting-group">
                        <div class="setting-title">Chart Settings</div>
                        <div class="setting-row">
                            <span>Grid Lines</span>
                            <label class="toggle-switch">
                                <input type="checkbox" checked id="showGrid" onchange="updateChartSettings()">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                        <div class="setting-row">
                            <span>Price Line</span>
                            <label class="toggle-switch">
                                <input type="checkbox" checked id="showPriceLine" onchange="updateChartSettings()">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Position Settings Dialog -->
    <div class="position-settings-dialog" id="positionSettingsDialog">
        <div class="dialog-header">
            <div class="dialog-title">Position Settings</div>
            <button class="dialog-close" onclick="closePositionSettings()">✕</button>
        </div>
        <div class="dialog-content">
            <div class="setting-section">
                <div class="setting-title">Stop Loss / Take Profit</div>
                <div class="setting-row">
                    <span>Stop Loss ($)</span>
                    <input type="number" class="setting-value-input" id="dialogSL" placeholder="Enter amount">
                </div>
                <div class="setting-row">
                    <span>Take Profit ($)</span>
                    <input type="number" class="setting-value-input" id="dialogTP" placeholder="Enter amount">
                </div>
            </div>
            
            <div class="setting-section">
                <div class="setting-title">Auto Trailing</div>
                <div class="setting-row">
                    <span>Enable Trailing</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="dialogTrailing">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="setting-row">
                    <span>Activation Profit ($)</span>
                    <input type="number" class="setting-value-input" id="dialogTrailingProfit" value="10">
                </div>
                <div class="setting-row">
                    <span>Trailing Distance ($)</span>
                    <input type="number" class="setting-value-input" id="dialogTrailingDistance" value="5">
                </div>
            </div>
            
            <div class="setting-section">
                <div class="setting-title">Auto Breakeven</div>
                <div class="setting-row">
                    <span>Enable Breakeven</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="dialogBreakeven">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="setting-row">
                    <span>Activation Profit ($)</span>
                    <input type="number" class="setting-value-input" id="dialogBreakevenProfit" value="5">
                </div>
            </div>
            
            <div class="setting-section">
                <div class="setting-title">Partial Close</div>
                <div class="setting-row">
                    <span>Close 50% at profit ($)</span>
                    <input type="number" class="setting-value-input" id="dialogPartialClose" placeholder="Disabled">
                </div>
            </div>
            
            <button class="apply-btn" onclick="applyPositionSettings()">Apply Settings</button>
        </div>
    </div>

    <!-- Status Bar -->
    <div class="status-bar">
        <div class="connection-status">
            <div class="status-dot disconnected" id="connectionDot"></div>
            <span id="connectionText">Disconnected</span>
        </div>
        <div class="status-info">
            <span>Spread: <span id="currentSpread">-</span></span>
            <span>Server Time: <span id="serverTime">00:00:00</span></span>
        </div>
    </div>

   <script>
    // Global Variables
    let hoveredDrawing = null;
    let ws = null;
    let positions = {};
    let dragStartPriceCenter = 0;
    let positionsData = [];
    let currentSymbol = 'EURUSD';
    let orderType = 'market'; // 'market' или 'limit'
    let currentTimeframe = 'H1';
    let chartData = [];
    let selectedTool = 'cursor';
    let drawingTool = null;
    let drawingColor = 'var(--accent-primary)';
    let selectedPendingOrderTicket = null;
    let drawings = [];
    let currentDrawing = null;
    let isDrawing = false;
    let isConnected = false;
    let currentBid = 0;
    let currentAsk = 0;
    let currentSpread = 0;
    let balance = 10000;
    let slUnit = 'pips';
    let tpUnit = 'pips';
    let riskMode = false;
    let selectedPositionId = null;
    let lastUpdateTime = 0;
    let updateThrottle = 100;
    let positionsUpdateQueue = [];
    let isUpdatingPositions = false;
    // Broker settings
    const BROKER_SUFFIX = '+';  // Суффикс брокера для символов
    
    // Chart variables
let canvas, ctx;
let chartWidth, chartHeight;
let candleWidth = 10;
let candleSpacing = 2;
let visibleCandles = 100;
let scrollOffset = 0;
let maxScroll = 0;
let priceMin = 1.0;
let priceMax = 1.1;
let priceRange = 0.1;
let mouseX = 0, mouseY = 0;
let isDragging = false;
let dragStartX = 0;
let dragStartY = 0;
let dragStartOffset = 0;
let hoveredPosition = null;
let draggingLine = null;
let draggedPosition = null;
let dragOriginalValue = 0;
let chartPadding = 80;
let isResizingYAxis = false;
let isResizingXAxis = false;
let yAxisStartY = 0;
let xAxisStartX = 0;
let priceRangeStart = 0;
let candleWidthStart = 0;

// Переменные для лимитных ордеров
let pendingOrderMode = false;
let pendingOrderType = null;
let pendingOrderPreview = null;
let pendingOrders = [];  
let pendingOrdersData = [];
let pendingOrderStep = 'price';
// Indicator Management System
let activeIndicators = {};
let indicatorsPanel = false;

function toggleIndicators() {
    indicatorsPanel = !indicatorsPanel;
    const panel = document.getElementById('indicatorsPanel');
    if (panel) {
        panel.style.display = indicatorsPanel ? 'block' : 'none';
    }
}

function addIndicator(type) {
    if (activeIndicators[type]) {
        showNotification('Indicator already active', 'warning');
        return;
    }
    
    // Create iframe for indicator
    const iframe = document.createElement('iframe');
    iframe.id = `indicator-${type}`;
    iframe.src = 'bpfx-indicator.html';
    iframe.style.position = 'absolute';
    iframe.style.top = '0';
    iframe.style.left = '0';
    iframe.style.width = '100%';
    iframe.style.height = '100%';
    iframe.style.border = 'none';
    iframe.style.pointerEvents = 'none';
    iframe.style.background = 'transparent';
    
    // Add to container
    const container = document.getElementById('indicatorContainer');
    container.appendChild(iframe);
    
    // Wait for iframe to load
    iframe.onload = function() {
        // Send initial data to indicator
        updateIndicatorData(type);
        
        // Отправляем текущую тему индикатору
        iframe.contentWindow.postMessage({
            type: 'themeChange',
            theme: currentTheme
        }, '*');
    };
    
    activeIndicators[type] = {
        iframe: iframe,
        enabled: true
    };
    
    // Добавляем кнопку настроек в панель инструментов
    const settingsBtn = document.createElement('button');
    settingsBtn.className = 'indicator-settings-btn';
    settingsBtn.innerHTML = '⚙ BPFX Settings';
    settingsBtn.style.cssText = `
        margin-left: 10px;
        padding: 8px 15px;
        background: linear-gradient(135deg, rgba(139, 92, 246, 0.2), rgba(0, 255, 255, 0.1));
        border: 1px solid rgba(0, 255, 255, 0.5);
        border-radius: 8px;
        color: #00ffff;
        font-size: 11px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s;
    `;

    settingsBtn.onclick = function() {
    document.getElementById('bpfxSettingsModal').style.display = 'block';
};

    // Добавляем кнопку рядом с таймфреймами
    const timeframeContainer = document.querySelector('.timeframe-selector').parentElement;
    timeframeContainer.appendChild(settingsBtn);
    
    updateActiveIndicatorsList();
    showNotification('BPFX indicator added', 'success');
    
    // Close panel
    toggleIndicators();
}

function removeIndicator(type) {
    if (!activeIndicators[type]) return;
    
    const indicator = activeIndicators[type];
    indicator.iframe.remove();
    delete activeIndicators[type];
    
    updateActiveIndicatorsList();
    showNotification('Indicator removed', 'info');
}

function updateActiveIndicatorsList() {
    const list = document.getElementById('activeIndicatorsList');
    if (!list) return;
    
    list.innerHTML = '';
    
    for (const [type, indicator] of Object.entries(activeIndicators)) {
        const item = document.createElement('div');
        item.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 8px; background: var(--bg-secondary); border-radius: 6px; margin-bottom: 5px;';
        
        item.innerHTML = `
            <div style="display: flex; align-items: center; gap: 10px;">
                <label class="toggle-switch" style="transform: scale(0.8);">
                    <input type="checkbox" ${indicator.enabled ? 'checked' : ''} onchange="toggleIndicatorVisibility('${type}', this.checked)">
                    <span class="toggle-slider"></span>
                </label>
                <span style="font-size: 12px;">BPFX</span>
            </div>
            <button onclick="window.removeIndicator('${type}')" style="background: var(--danger); color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 11px;">Remove</button>
        `;
        
        list.appendChild(item);
    }
}

function toggleIndicatorVisibility(type, enabled) {
    if (!activeIndicators[type]) return;
    
    activeIndicators[type].enabled = enabled;
    activeIndicators[type].iframe.style.display = enabled ? 'block' : 'none';
}

function updateIndicatorData(type) {
    if (!activeIndicators[type] || !chartData || chartData.length === 0) return;
    
    const indicator = activeIndicators[type];
    
    // Send chart data to indicator
    indicator.iframe.contentWindow.postMessage({
        type: 'updateData',
        candles: chartData
    }, '*');
}

function updateAllIndicators() {
    for (const type of Object.keys(activeIndicators)) {
        updateIndicatorData(type);
    }
}

// Theme Definitions
const themes = {
    cyberpunk: {
        '--bg-primary': '#0a0e1a',
        '--bg-secondary': '#141824',
        '--bg-panel': 'rgba(20, 24, 36, 0.95)',
        '--accent-primary': '#00ffff',
        '--accent-secondary': '#ff00ff',
        '--accent-tertiary': '#8b5cf6',
        '--text-primary': '#ffffff',
        '--text-secondary': '#94a3b8',
        '--success': '#22c55e',
        '--danger': '#ef4444',
        '--warning': '#f59e0b',
        '--border': 'rgba(139, 92, 246, 0.3)',
        '--candle-bull': '#00ffff',
        '--candle-bear': '#ff00ff',
        '--candle-wick': '#ffffff'
    },
    matrix: {
        '--bg-primary': '#000000',
        '--bg-secondary': '#0a0a0a',
        '--bg-panel': 'rgba(0, 20, 0, 0.95)',
        '--accent-primary': '#00ff00',
        '--accent-secondary': '#00cc00',
        '--accent-tertiary': '#006600',
        '--text-primary': '#00ff00',
        '--text-secondary': '#008800',
        '--success': '#00ff00',
        '--danger': '#ff0000',
        '--warning': '#ffff00',
        '--border': 'rgba(0, 255, 0, 0.3)',
        '--candle-bull': '#00ff00',
        '--candle-bear': '#ff0000',
        '--candle-wick': '#00ff00'
    },
    dark: {
        '--bg-primary': '#1a1a1a',
        '--bg-secondary': '#2a2a2a',
        '--bg-panel': 'rgba(30, 30, 30, 0.95)',
        '--accent-primary': '#4a9eff',
        '--accent-secondary': '#ff6b6b',
        '--accent-tertiary': '#666666',
        '--text-primary': '#ffffff',
        '--text-secondary': '#bbbbbb',
        '--success': '#4caf50',
        '--danger': '#f44336',
        '--warning': '#ff9800',
        '--border': 'rgba(255, 255, 255, 0.1)',
        '--candle-bull': '#4caf50',
        '--candle-bear': '#f44336',
        '--candle-wick': '#888888'
    },
    light: {
        '--bg-primary': '#ffffff',
        '--bg-secondary': '#f5f5f5',
        '--bg-panel': 'rgba(255, 255, 255, 0.95)',
        '--accent-primary': '#2196f3',
        '--accent-secondary': '#ff4081',
        '--accent-tertiary': '#9c27b0',
        '--text-primary': '#333333',
        '--text-secondary': '#666666',
        '--success': '#4caf50',
        '--danger': '#f44336',
        '--warning': '#ff9800',
        '--border': 'rgba(0, 0, 0, 0.1)',
        '--candle-bull': '#4caf50',
        '--candle-bear': '#f44336',
        '--candle-wick': '#666666'
    },
    ocean: {
        '--bg-primary': '#001f3f',
        '--bg-secondary': '#003366',
        '--bg-panel': 'rgba(0, 51, 102, 0.95)',
        '--accent-primary': '#00bcd4',
        '--accent-secondary': '#00acc1',
        '--accent-tertiary': '#0097a7',
        '--text-primary': '#ffffff',
        '--text-secondary': '#b3e5fc',
        '--success': '#00e676',
        '--danger': '#ff5252',
        '--warning': '#ffc107',
        '--border': 'rgba(0, 188, 212, 0.3)',
        '--candle-bull': '#00e5ff',
        '--candle-bear': '#ff1744',
        '--candle-wick': '#80deea'
    },
    sunset: {
        '--bg-primary': '#1a0033',
        '--bg-secondary': '#330066',
        '--bg-panel': 'rgba(51, 0, 102, 0.95)',
        '--accent-primary': '#ff6b6b',
        '--accent-secondary': '#ffa500',
        '--accent-tertiary': '#ff1744',
        '--text-primary': '#ffffff',
        '--text-secondary': '#ffccbc',
        '--success': '#76ff03',
        '--danger': '#ff1744',
        '--warning': '#ffab00',
        '--border': 'rgba(255, 107, 107, 0.3)',
        '--candle-bull': '#ffeb3b',
        '--candle-bear': '#ff5722',
        '--candle-wick': '#ffa726'
    },
    neon: {
        '--bg-primary': '#0a0a0a',
        '--bg-secondary': '#1a1a1a',
        '--bg-panel': 'rgba(26, 26, 26, 0.95)',
        '--accent-primary': '#ff00ff',
        '--accent-secondary': '#00ffff',
        '--accent-tertiary': '#9900ff',
        '--text-primary': '#ffffff',
        '--text-secondary': '#cccccc',
        '--success': '#00ff00',
        '--danger': '#ff0066',
        '--warning': '#ff9900',
        '--border': 'rgba(255, 0, 255, 0.3)',
        '--candle-bull': '#00ff00',
        '--candle-bear': '#ff0080',
        '--candle-wick': '#ff00ff'
    },
    royal: {
        '--bg-primary': '#1a0033',
        '--bg-secondary': '#2d004d',
        '--bg-panel': 'rgba(45, 0, 77, 0.95)',
        '--accent-primary': '#ffd700',
        '--accent-secondary': '#ff69b4',
        '--accent-tertiary': '#9370db',
        '--text-primary': '#ffffff',
        '--text-secondary': '#dda0dd',
        '--success': '#32cd32',
        '--danger': '#dc143c',
        '--warning': '#ffa500',
        '--border': 'rgba(255, 215, 0, 0.3)',
        '--candle-bull': '#ffd700',
        '--candle-bear': '#dc143c',
        '--candle-wick': '#daa520'
    }
};

let currentTheme = localStorage.getItem('currentTheme') || 'cyberpunk';

// Функции для управления preset настройками автоматизации
function togglePresetTrailing() {
    const isChecked = document.getElementById('presetTrailing').checked;
    const trailingInputs = document.getElementById('trailingInputs');
    
    if (isChecked) {
        trailingInputs.style.display = 'flex';
    } else {
        trailingInputs.style.display = 'none';
    }
}

function togglePresetBreakeven() {
    const isChecked = document.getElementById('presetBreakeven').checked;
    const breakevenInputs = document.getElementById('breakevenInputs');
    
    if (isChecked) {
        breakevenInputs.style.display = 'flex';
    } else {
        breakevenInputs.style.display = 'none';
    }
}
        // Initialize WebSocket
        function initWebSocket() {
            try {
                ws = new WebSocket('ws://127.0.0.1:8080');
                
                ws.onopen = () => {
                    isConnected = true;
                    updateConnectionStatus(true);
                    showNotification('Connected to server', 'success');
                    
                    // Request initial data
                    ws.send(JSON.stringify({
                        type: 'request',
                        data: 'initial'
                    }));
                    
                    // Subscribe to current symbol
                    ws.send(JSON.stringify({
                        type: 'subscribe',
                        symbol: getBrokerSymbol(currentSymbol)
                    }));
                    
                    // Request chart data
                    requestChartData();
                };
                
                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    handleServerMessage(data);
                };
                
                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    showNotification('Connection error', 'error');
                };
                
                ws.onclose = () => {
                    isConnected = false;
                    updateConnectionStatus(false);
                    showNotification('Disconnected from server', 'error');
                    setTimeout(initWebSocket, 5000); // Auto-reconnect
                };
            } catch (error) {
                console.error('Failed to connect:', error);
                updateConnectionStatus(false);
                setTimeout(initWebSocket, 5000);
            }
        }
function updateAllIndicators() {
    for (const type of Object.keys(activeIndicators)) {
        updateIndicatorData(type);
    }
}

       function handleServerMessage(data) {
    switch(data.type) {
        case 'tick':
            updatePrice(data);
            updateLastCandle(data);
            break;
        case 'account':
            updateAccount(data);
            break;
        case 'positions':
            queuePositionsUpdate(data.positions);
            break;
        case 'pending_orders':  // ДОБАВИТЬ ЭТОТ CASE
            updatePendingOrders(data.orders);
            break;
        case 'execution':
            handleExecution(data);
            break;
        case 'chart':
            updateChart(data.candles);
            break;
        case 'notification':
            showNotification(data.message, data.level || 'info');
            break;
        case 'error':
            showNotification(data.message, 'error');
            break;
    }
}

        // Queue positions update to avoid flickering
        function queuePositionsUpdate(newPositions) {
            positionsUpdateQueue.push(newPositions);
            if (!isUpdatingPositions) {
                processPositionsQueue();
            }
        }

        // Process positions queue with batching
        async function processPositionsQueue() {
            if (positionsUpdateQueue.length === 0) {
                isUpdatingPositions = false;
                return;
            }
            
            isUpdatingPositions = true;
            const positions = positionsUpdateQueue.shift();
            
            // Clear remaining queue and use only latest data
            if (positionsUpdateQueue.length > 0) {
                positionsUpdateQueue = [positionsUpdateQueue[positionsUpdateQueue.length - 1]];
            }
            
            updatePositions(positions);
            
            // Throttle updates
            setTimeout(() => {
                processPositionsQueue();
            }, updateThrottle);
        }

        // Update prices
        function updatePrice(data) {
            if (data.symbol === currentSymbol) {
                currentBid = data.bid;
                currentAsk = data.ask;
                currentSpread = data.spread;
                
                const price = document.getElementById('currentPrice');
                const change = document.getElementById('priceChange');
                const buyPrice = document.getElementById('buyPrice');
                const sellPrice = document.getElementById('sellPrice');
                const spread = document.getElementById('currentSpread');
                
                price.textContent = formatPrice(data.bid);
                buyPrice.textContent = formatPrice(data.ask);
                sellPrice.textContent = formatPrice(data.bid);
                spread.textContent = data.spread.toFixed(1);
                
                // Calculate change
                if (data.open) {
                    const changePercent = ((data.bid - data.open) / data.open * 100).toFixed(2);
                    change.textContent = (changePercent >= 0 ? '+' : '') + changePercent + '%';
                    
                    price.className = changePercent >= 0 ? 'current-price price-up' : 'current-price price-down';
                    change.className = changePercent >= 0 ? 'price-change price-up' : 'price-change price-down';
                }
                
                // Update risk calculations if in risk mode
                if (riskMode) {
                    calculateRiskValues();
                }
                
                // Redraw chart
                drawChart();
            }
        }

        // Format price based on symbol
        function formatPrice(price) {
            if (!price && price !== 0) return '-';
            
            if (currentSymbol.includes('JPY')) {
                return price.toFixed(3);
            } else if (currentSymbol.includes('BTC')) {
                return price.toFixed(2);
            } else if (currentSymbol.includes('XAU')) {
                return price.toFixed(2);
            } else {
                return price.toFixed(5);
            }
        }

        // Update account info
        function updateAccount(data) {
    balance = data.balance;
    document.getElementById('balance').textContent = '$' + data.balance.toFixed(2);
    document.getElementById('equity').textContent = '$' + data.equity.toFixed(2);
    document.getElementById('margin').textContent = '$' + data.margin.toFixed(2);
    document.getElementById('freeMargin').textContent = '$' + data.freeMargin.toFixed(2);
    document.getElementById('marginLevel').textContent = data.marginLevel.toFixed(2) + '%';

    // --- ДОБАВЛЕННАЯ ЛОГИКА ---
    const accountModeEl = document.getElementById('accountMode');
    if (data.server && data.server.toLowerCase().includes('demo')) {
        // Если в имени сервера есть слово "demo", показываем значок
        accountModeEl.innerHTML = '<span class="demo-badge">DEMO</span>';
    } else {
        // В противном случае, оставляем это место пустым
        accountModeEl.innerHTML = '';
    }
    // --- КОНЕЦ ДОБАВЛЕННОЙ ЛОГИКИ ---
}

        // Update positions with smooth rendering
// Update positions with smooth rendering
function updatePositions(positionsArray) {
    positionsData = positionsArray || [];
    const tbody = document.getElementById('positionsTableBody');
    const tfoot = document.getElementById('positionsTableFooter'); 

    if (positionsData.length === 0) {
        tbody.innerHTML = `
            <tr>
                <td colspan="11" style="text-align: center; color: var(--text-secondary); padding: 40px;">
                    No open positions
                </td>
            </tr>
        `;
        tfoot.style.display = 'none'; 
        return;
    }
    
    tfoot.style.display = 'table-footer-group'; 

    let totalPositions = positionsData.length;
    let totalVolume = 0;
    let totalProfit = 0;

    positionsData.forEach(pos => {
        totalVolume += pos.volume;
        // ПЕРЕСЧИТЫВАЕМ PROFIT ПРАВИЛЬНО
        const realProfit = calculateDollarValueFromPriceDiff(
            pos.openPrice,
            pos.currentPrice || pos.openPrice,
            pos.volume,
            pos.symbol
        ) * (pos.type === 'buy' ? 
            (pos.currentPrice - pos.openPrice > 0 ? 1 : -1) : 
            (pos.openPrice - pos.currentPrice > 0 ? 1 : -1));
        
        pos.profit = realProfit; // Перезаписываем неправильный profit
        totalProfit += realProfit;
    });

    const newHTML = positionsData.map(pos => {
        const profitClass = pos.profit >= 0 ? 'positive' : 'negative';
        const typeClass = pos.type === 'buy' ? 'buy' : 'sell';
        
        let slDisplay = '-';
        let tpDisplay = '-';
        
        if (pos.sl) {
            const slDollar = calculateDollarValueFromPriceDiff(pos.openPrice, pos.sl, pos.volume, pos.symbol);
            slDisplay = `$${slDollar.toFixed(2)}`;
        }
        
        if (pos.tp) {
            const tpDollar = calculateDollarValueFromPriceDiff(pos.openPrice, pos.tp, pos.volume, pos.symbol);
            tpDisplay = `$${tpDollar.toFixed(2)}`;
        }
        
        return `
            <tr data-position-id="${pos.id}" onclick="selectPosition(${pos.id})" 
                onmouseenter="highlightPosition(${pos.id})" 
                onmouseleave="unhighlightPosition()">
                <td class="position-symbol">${pos.symbol}</td>
                <td><span class="position-type-badge ${typeClass}">${pos.type.toUpperCase()}</span></td>
                <td>${pos.volume.toFixed(2)}</td>
                <td>${formatPrice(pos.openPrice)}</td>
                <td>${formatPrice(pos.currentPrice || pos.openPrice)}</td>
                <td>${slDisplay}</td>
                <td>${tpDisplay}</td>
                <td class="profit-value ${profitClass}">
                    ${pos.profit >= 0 ? '+' : ''}$${Math.abs(pos.profit).toFixed(2)}
                </td>
                <td>
                    <label class="toggle-switch" style="transform: scale(0.8);">
                        <input type="checkbox" id="trailing_${pos.id}" 
                               onchange="toggleTrailing(${pos.id}, this.checked)"
                               ${positions[pos.id]?.trailing ? 'checked' : ''}>
                        <span class="toggle-slider"></span>
                    </label>
                </td>
                <td>
                    <label class="toggle-switch" style="transform: scale(0.8);">
                        <input type="checkbox" id="breakeven_${pos.id}"
                               onchange="toggleBreakeven(${pos.id}, this.checked)"
                               ${positions[pos.id]?.breakeven ? 'checked' : ''}>
                        <span class="toggle-slider"></span>
                    </label>
                </td>
                <td>
                    <div class="position-actions">
                        <button class="action-btn" onclick="openPositionSettings(${pos.id}); event.stopPropagation();">Settings</button>
                        <button class="action-btn" onclick="closeHalfPosition(${pos.id}); event.stopPropagation();">Close 50%</button>
                        <button class="action-btn" onclick="closePosition(${pos.id}); event.stopPropagation();">Close</button>
                    </div>
                </td>
            </tr>
        `;
    }).join('');
    
    if (tbody.innerHTML !== newHTML) {
        tbody.innerHTML = newHTML;
    }
    
    const totalProfitEl = document.getElementById('totalProfit');
    document.getElementById('totalVolume').textContent = totalVolume.toFixed(2);
    totalProfitEl.textContent = `${totalProfit >= 0 ? '+' : ''}$${Math.abs(totalProfit).toFixed(2)}`;
    totalProfitEl.className = totalProfit >= 0 ? 'profit-value positive' : 'profit-value negative';
    
    const summaryRowFirstCell = tfoot.querySelector('.summary-row td:first-child');
    summaryRowFirstCell.textContent = `Total (${totalPositions} Pos.):`;
            
    positionsData.forEach(pos => {
        if (!positions[pos.id]) {
            positions[pos.id] = { trailing: false, breakeven: false, trailingProfit: 10, trailingDistance: 5, breakevenProfit: 5 };
        }
    });
    
    drawChart();
}
function updatePendingOrders(orders) {
    pendingOrdersData = orders || [];
    pendingOrders = orders || [];  // для обратной совместимости
    
    // Обновляем счетчик если элемент существует
    const countBadge = document.getElementById('pendingOrdersCount');
    if (countBadge) {
        if (pendingOrdersData.length > 0) {
            countBadge.textContent = pendingOrdersData.length;
            countBadge.style.display = 'inline-block';
        } else 
        {
            countBadge.style.display = 'none';
        }
    }
    
    // Обновляем таблицу если элемент существует
    const tbody = document.getElementById('pendingOrdersTableBody');
    if (tbody) {
        updatePendingOrdersTable();
    }
    
    drawChart();
}
function updatePendingOrdersTable() {
    const tbody = document.getElementById('pendingOrdersTableBody');
    const tfoot = document.getElementById('pendingOrdersTableFooter');
    
    if (!tbody) return;
    
    if (pendingOrdersData.length === 0) {
        tbody.innerHTML = `
            <tr>
                <td colspan="10" style="text-align: center; color: var(--text-secondary); padding: 40px;">
                    No pending orders
                </td>
            </tr>
        `;
        if (tfoot) tfoot.style.display = 'none';
        return;
    }
    
    if (tfoot) tfoot.style.display = 'table-footer-group';
    
    let totalVolume = 0;
    pendingOrdersData.forEach(order => {
        totalVolume += order.volume;
    });
    
    const newHTML = pendingOrdersData.map(order => {
        const isBuyLimit = order.type === 'buy_limit';
        let distance;
        if (order.symbol.includes('XAU') || order.symbol.includes('GOLD')) {
            distance = Math.abs(order.price - currentBid) / 0.1;
        } else if (order.symbol.includes('JPY')) {
            distance = Math.abs(order.price - currentBid) / 0.001;
        } else {
            distance = Math.abs(order.price - currentBid) / 0.00001;
        }
        const distanceText = order.price > currentBid ? `+${distance.toFixed(1)}` : `-${distance.toFixed(1)}`;
        
        return `
            <tr>
                <td>#${order.ticket}</td>
                <td class="position-symbol">${order.symbol}</td>
                <td><span class="position-type-badge ${isBuyLimit ? 'buy' : 'sell'}">${order.type.replace('_', ' ').toUpperCase()}</span></td>
                <td>${order.volume.toFixed(2)}</td>
                <td>${formatPrice(order.price)}</td>
                <td>${distanceText} pips</td>
                <td>${order.sl ? formatPrice(order.sl) : '-'}</td>
                <td>${order.tp ? formatPrice(order.tp) : '-'}</td>
                <td>${new Date(order.time_setup).toLocaleTimeString('en-US', {hour: '2-digit', minute: '2-digit'})}</td>
                <td>
                    <div class="position-actions">
                        <button class="action-btn" onclick="modifyPendingOrder(${order.ticket})">Modify</button>
                        <button class="action-btn" onclick="cancelPendingOrder(${order.ticket})">Cancel</button>
                    </div>
                </td>
            </tr>
        `;
    }).join('');
    
    tbody.innerHTML = newHTML;
    
    if (document.getElementById('totalPendingOrders')) {
        document.getElementById('totalPendingOrders').textContent = `Total: ${pendingOrdersData.length} Orders`;
    }
    if (document.getElementById('totalPendingVolume')) {
        document.getElementById('totalPendingVolume').textContent = totalVolume.toFixed(2);
    }
}
function cancelPendingOrder(ticket) {
    console.log('Cancel order called with ticket:', ticket, 'Type:', typeof ticket);
    
    if (!confirm(`Cancel order #${ticket}?`)) {
        console.log('User cancelled confirmation');
        return;
    }
    
    if (ws && ws.readyState === WebSocket.OPEN) {
        const message = {
            type: 'cancelOrder',
            ticket: parseInt(ticket)  // Преобразуем в число
        };
        console.log('Sending message:', message);
        ws.send(JSON.stringify(message));
    } else {
        console.log('WebSocket not ready, state:', ws ? ws.readyState : 'null');
    }
}
function cancelAllPendingOrders() {
    if (!confirm('Cancel all pending orders?')) return;
    
    pendingOrdersData.forEach(order => {
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({
                type: 'cancelOrder',
                ticket: order.ticket
            }));
        }
    });
}
function modifyPendingOrder(ticket) {
    const order = pendingOrdersData.find(o => o.ticket === ticket);
    if (!order) return;
    
    selectedPendingOrderTicket = ticket;
    
    // Заполняем поля в диалоге
    const dialog = document.getElementById('pendingOrderSettingsDialog');
    if (!dialog) {
        // Если диалога нет, создаем его
        createPendingOrderDialog();
        return;
    }
    
    document.getElementById('dialogPendingPrice').value = order.price;
    document.getElementById('dialogPendingSL').value = order.sl || '';
    document.getElementById('dialogPendingTP').value = order.tp || '';
    
    dialog.classList.add('active');
}
function createPendingOrderDialog() {
    const dialogHTML = `
        <div class="position-settings-dialog" id="pendingOrderSettingsDialog">
            <div class="dialog-header">
                <div class="dialog-title">Modify Pending Order</div>
                <button class="dialog-close" onclick="closePendingOrderSettings()">✕</button>
            </div>
            <div class="dialog-content">
                <div class="setting-section">
                    <div class="setting-title">Order Settings</div>
                    <div class="setting-row">
                        <span>Price</span>
                        <input type="number" class="setting-value-input" id="dialogPendingPrice" step="0.00001">
                    </div>
                    <div class="setting-row">
                        <span>Stop Loss</span>
                        <input type="number" class="setting-value-input" id="dialogPendingSL" step="0.00001" placeholder="Optional">
                    </div>
                    <div class="setting-row">
                        <span>Take Profit</span>
                        <input type="number" class="setting-value-input" id="dialogPendingTP" step="0.00001" placeholder="Optional">
                    </div>
                </div>
                
                <div class="setting-section">
                    <div class="setting-title">Auto Settings (After Activation)</div>
                    <div class="setting-row">
                        <span>Enable Trailing</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="dialogPendingTrailing">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    <div class="setting-row">
                        <span>Trailing Start ($)</span>
                        <input type="number" class="setting-value-input" id="dialogPendingTrailingProfit" value="10">
                    </div>
                    <div class="setting-row">
                        <span>Enable Breakeven</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="dialogPendingBreakeven">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    <div class="setting-row">
                        <span>Breakeven at ($)</span>
                        <input type="number" class="setting-value-input" id="dialogPendingBreakevenProfit" value="5">
                    </div>
                </div>
                
                <button class="apply-btn" onclick="applyPendingOrderSettings()">Apply Changes</button>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', dialogHTML);
    
    const dialog = document.getElementById('pendingOrderSettingsDialog');
    const order = pendingOrdersData.find(o => o.ticket === selectedPendingOrderTicket);
    if (order) {
        document.getElementById('dialogPendingPrice').value = order.price;
        document.getElementById('dialogPendingSL').value = order.sl || '';
        document.getElementById('dialogPendingTP').value = order.tp || '';
    }
    dialog.classList.add('active');
}
function closePendingOrderSettings() {
    const dialog = document.getElementById('pendingOrderSettingsDialog');
    if (dialog) {
        dialog.classList.remove('active');
    }
    selectedPendingOrderTicket = null;
}
function applyPendingOrderSettings() {
    if (!selectedPendingOrderTicket) return;
    
    const newPrice = parseFloat(document.getElementById('dialogPendingPrice').value);
    const newSL = parseFloat(document.getElementById('dialogPendingSL').value) || 0;
    const newTP = parseFloat(document.getElementById('dialogPendingTP').value) || 0;
    
    const trailing = document.getElementById('dialogPendingTrailing').checked;
    const trailingProfit = parseFloat(document.getElementById('dialogPendingTrailingProfit').value);
    const breakeven = document.getElementById('dialogPendingBreakeven').checked;
    const breakevenProfit = parseFloat(document.getElementById('dialogPendingBreakevenProfit').value);
    
    if (ws && ws.readyState === WebSocket.OPEN) {
        // Отправляем запрос на модификацию ордера
        ws.send(JSON.stringify({
            type: 'modifyPending',
            ticket: selectedPendingOrderTicket,
            price: newPrice,
            sl: newSL,
            tp: newTP,
            automation: {
                trailing: trailing,
                trailingProfit: trailingProfit,
                breakeven: breakeven,
                breakevenProfit: breakevenProfit
            }
        }));
    }
    
    closePendingOrderSettings();
    showNotification('Pending order modification sent', 'info');
}
function switchPositionsTab(tab) {
    // Обновляем активные вкладки
    document.querySelectorAll('.positions-panel-tab').forEach(t => {
        t.classList.remove('active');
    });
    document.querySelectorAll('.positions-panel-tab-content').forEach(c => {
        c.classList.remove('active');
    });

    // Активируем нужную вкладку
    if (tab === 'positions') {
        const posTab = document.querySelector('.positions-panel-tab:first-child');
        if (posTab) posTab.classList.add('active');
        const posContent = document.getElementById('positions-tab');
        if (posContent) posContent.classList.add('active');
    } else if (tab === 'pending') {
        const pendTab = document.querySelector('.positions-panel-tab:last-child');
        if (pendTab) pendTab.classList.add('active');
        const pendContent = document.getElementById('pending-tab');
        if (pendContent) pendContent.classList.add('active');
    }
}
// Calculate dollar value from pips - ИСПРАВЛЕННАЯ ВЕРСИЯ
function calculateDollarValueFromPriceDiff(openPrice, stopPrice, volume, symbol) {
    const priceDiff = Math.abs(openPrice - stopPrice);

    // Специальный расчет для золота
    if (symbol.includes('XAU') || symbol.includes('GOLD')) {
        // Для золота: изменение цены на $1 при 0.01 лоте = $1 профита
        return priceDiff * volume * 100;
    }
    
    // Криптовалюты - прямой расчет
    if (symbol.includes('BTC') || symbol.includes('ETH')) {
        return priceDiff * volume;
    }

    // Расчет для JPY пар (3 знака после точки)
    if (symbol.includes('JPY')) {
        const points = priceDiff / 0.001;  // Для JPY point = 0.001
        return points * volume;  // 100 points = $1 при 0.01 лоте
    }

    // Стандартный расчет для Forex пар (EURUSD, GBPUSD и т.д.)
    // По логике брокера: движение на 0.001 (100 points) = $1 при 0.01 лоте
    // Формула: priceDiff * volume * 100000
    return priceDiff * volume * 100000;
}

        // Toggle SL unit
        function toggleSLUnit(unit) {
            slUnit = unit;
            document.getElementById('slUnitPips').classList.toggle('active', unit === 'pips');
            document.getElementById('slUnitDollar').classList.toggle('active', unit === 'dollar');
            
            const input = document.getElementById('stopLoss');
            input.placeholder = unit === 'pips' ? 'Points' : 'Dollar amount';
        }

        // Toggle TP unit
        function toggleTPUnit(unit) {
            tpUnit = unit;
            document.getElementById('tpUnitPips').classList.toggle('active', unit === 'pips');
            document.getElementById('tpUnitDollar').classList.toggle('active', unit === 'dollar');
            
            const input = document.getElementById('takeProfit');
            input.placeholder = unit === 'pips' ? 'Points' : 'Dollar amount';
        }

        // Toggle risk mode
        function toggleRiskMode() {
            riskMode = document.getElementById('riskModeToggle').checked;
            document.getElementById('riskInputs').classList.toggle('active', riskMode);
            document.getElementById('calculatedValues').style.display = riskMode ? 'block' : 'none';
            document.getElementById('volumeGroup').style.display = riskMode ? 'none' : 'block';
            
            if (riskMode) {
                calculateRiskValues();
            }
        }

        // Calculate risk values
        function calculateRiskValues() {
            const riskPercent = parseFloat(document.getElementById('riskPercent').value) || 1;
            const rewardRatio = parseFloat(document.getElementById('rewardRatio').value) || 3;
            
            const riskAmount = (balance * riskPercent) / 100;
            const profitAmount = riskAmount * rewardRatio;
            
            document.getElementById('calcRiskAmount').textContent = `$${riskAmount.toFixed(2)}`;
            document.getElementById('calcProfit').textContent = `$${profitAmount.toFixed(2)}`;
            
            // Calculate volume based on risk
            const stopLoss = parseFloat(document.getElementById('stopLoss').value) || 50;
            const stopLossPoints = slUnit === 'dollar' ? calculatePipsFromDollar(stopLoss, 0.01) : stopLoss;
            
            if (stopLossPoints > 0) {
                const calculatedVolume = riskAmount / (stopLossPoints * 10);
                document.getElementById('calcVolume').textContent = calculatedVolume.toFixed(2);
            }
        }

        // Position management functions
        function selectPosition(positionId) {
            selectedPositionId = positionId;
            
            // Update UI selection
            document.querySelectorAll('.positions-table tr').forEach(row => {
                row.classList.remove('selected');
            });
            
            const selectedRow = document.querySelector(`tr[data-position-id="${positionId}"]`);
            if (selectedRow) {
                selectedRow.classList.add('selected');
            }
        }

        function highlightPosition(positionId) {
            hoveredPosition = positionId;
            drawChart();
        }

        function unhighlightPosition() {
            hoveredPosition = null;
            drawChart();
        }

       function openPositionSettings(positionId) {
    selectedPositionId = positionId;
    const pos = positionsData.find(p => p.id === positionId);
    if (!pos) return;
    
    // ИСПОЛЬЗУЕМ НОВУЮ ПРАВИЛЬНУЮ ФУНКЦИЮ ДЛЯ РАСЧЕТА
    document.getElementById('dialogSL').value = pos.sl ? 
        calculateDollarValueFromPriceDiff(pos.openPrice, pos.sl, pos.volume, pos.symbol).toFixed(2) : '';
    document.getElementById('dialogTP').value = pos.tp ? 
        calculateDollarValueFromPriceDiff(pos.openPrice, pos.tp, pos.volume, pos.symbol).toFixed(2) : '';
    
    const settings = positions[positionId] || {};
    document.getElementById('dialogTrailing').checked = settings.trailing || false;
    document.getElementById('dialogTrailingProfit').value = settings.trailingProfit || 10;
    document.getElementById('dialogTrailingDistance').value = settings.trailingDistance || 5;
    document.getElementById('dialogBreakeven').checked = settings.breakeven || false;
    document.getElementById('dialogBreakevenProfit').value = settings.breakevenProfit || 5;
    
    document.getElementById('positionSettingsDialog').classList.add('active');
}

function closePositionSettings() {
    document.getElementById('positionSettingsDialog').classList.remove('active');
}

function applyPositionSettings() {
    if (!selectedPositionId) return;
    
    const pos = positionsData.find(p => p.id === selectedPositionId);
    if (!pos) return;
    
    const slDollar = parseFloat(document.getElementById('dialogSL').value);
    const tpDollar = parseFloat(document.getElementById('dialogTP').value);
    
    if (ws && ws.readyState === WebSocket.OPEN) {
        // Отправляем modify ТОЛЬКО если есть изменения в SL или TP
        if (!isNaN(slDollar) || !isNaN(tpDollar)) {
            let modification = { type: 'modify', positionId: selectedPositionId };
            
            if (!isNaN(slDollar) && slDollar > 0) {
                let priceChange;
                if (pos.symbol.includes('XAU') || pos.symbol.includes('GOLD')) {
                    priceChange = slDollar / (pos.volume * 100);
                } else if (pos.symbol.includes('BTC') || pos.symbol.includes('ETH')) {
                    priceChange = slDollar / pos.volume;
                } else if (pos.symbol.includes('JPY')) {
                    priceChange = (slDollar / pos.volume) * 0.001;
                } else {
                    // Для Forex (EURUSD, GBPUSD): движение на 0.001 = $1 при 0.01 лоте
                    priceChange = slDollar / (pos.volume * 100000);
                }
                
                modification.sl_price = pos.type === 'buy' ? 
                    pos.openPrice - priceChange : 
                    pos.openPrice + priceChange;
            } else {
                modification.sl_price = 0;
            }

            if (!isNaN(tpDollar) && tpDollar > 0) {
                let priceChange;
                if (pos.symbol.includes('XAU') || pos.symbol.includes('GOLD')) {
                    priceChange = tpDollar / (pos.volume * 100);
                } else if (pos.symbol.includes('BTC') || pos.symbol.includes('ETH')) {
                    priceChange = tpDollar / pos.volume;
                } else if (pos.symbol.includes('JPY')) {
                    priceChange = (tpDollar / pos.volume) * 0.001;
                } else {
                    // Для Forex (EURUSD, GBPUSD): движение на 0.001 = $1 при 0.01 лоте
                    priceChange = tpDollar / (pos.volume * 100000);
                }
                
                modification.tp_price = pos.type === 'buy' ? 
                    pos.openPrice + priceChange : 
                    pos.openPrice - priceChange;
            } else {
                modification.tp_price = 0;
            }
            
            ws.send(JSON.stringify(modification));
        }
        
        // Настройки автоматизации отправляем всегда
        const trailing = document.getElementById('dialogTrailing').checked;
        const trailingProfit = parseFloat(document.getElementById('dialogTrailingProfit').value);
        const trailingDistance = parseFloat(document.getElementById('dialogTrailingDistance').value);
        const breakeven = document.getElementById('dialogBreakeven').checked;
        const breakevenProfit = parseFloat(document.getElementById('dialogBreakevenProfit').value);
        const partialClose = parseFloat(document.getElementById('dialogPartialClose').value);

        positions[selectedPositionId] = {
            trailing,
            trailingProfit,
            trailingDistance,
            breakeven,
            breakevenProfit,
            partialClose: partialClose || null
        };

        ws.send(JSON.stringify({
            type: 'automation',
            positionId: selectedPositionId,
            settings: positions[selectedPositionId]
        }));
    }
    
    closePositionSettings();
    showNotification('Position settings updated', 'success');
}

        function toggleTrailing(positionId, enabled) {
            if (!positions[positionId]) {
                positions[positionId] = {};
            }
            positions[positionId].trailing = enabled;
            
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'automation',
                    positionId: positionId,
                    automationType: 'trailing',
                    settings: {
                        enabled: enabled,
                        profitTrigger: positions[positionId].trailingProfit || 10,
                        distance: positions[positionId].trailingDistance || 5
                    }
                }));
            }
            
            showNotification(
                enabled ? `Auto-trailing activated for position #${positionId}` : 
                         `Auto-trailing deactivated for position #${positionId}`,
                enabled ? 'success' : 'info'
            );
        }

        function toggleBreakeven(positionId, enabled) {
            if (!positions[positionId]) {
                positions[positionId] = {};
            }
            positions[positionId].breakeven = enabled;
            
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'automation',
                    positionId: positionId,
                    automationType: 'breakeven',
                    settings: {
                        enabled: enabled,
                        profitTrigger: positions[positionId].breakevenProfit || 5
                    }
                }));
            }
            
            showNotification(
                enabled ? `Auto-breakeven activated for position #${positionId}` : 
                         `Auto-breakeven deactivated for position #${positionId}`,
                enabled ? 'success' : 'info'
            );
        }

      function closeHalfPosition(positionId) {
    if (!isConnected) {
        showNotification('Not connected to server', 'error');
        return;
    }
    
    const pos = positionsData.find(p => p.id === positionId);
    if (!pos) return;
    
    const halfVolume = (pos.volume / 2).toFixed(2);
    
    ws.send(JSON.stringify({
        type: 'closePartial',
        positionId: positionId,
        volume: parseFloat(halfVolume)
    }));
}

function executeTrade(type) {
    if (!isConnected) {
        showNotification('Not connected to server', 'error');
        return;
    }
    
    const volume = parseFloat(document.getElementById('lotSize').value);
    const slValue = parseFloat(document.getElementById('stopLoss').value) || null;
    const tpValue = parseFloat(document.getElementById('takeProfit').value) || null;

    const order = {
        type: 'order',  // Всегда 'order' для всех типов ордеров
        symbol: getBrokerSymbol(currentSymbol),
        volume: volume,
        action: type,  // 'buy' или 'sell'
        sl: slValue,
        tp: tpValue,
        sl_unit: slUnit,
        tp_unit: tpUnit
    };
    
    // Собираем preset настройки автоматизации
    if (document.getElementById('presetTrailing').checked) {
        order.trailing = true;
        order.trailing_profit = parseFloat(document.getElementById('presetTrailingProfit').value) || 10;
        order.trailing_distance = parseFloat(document.getElementById('presetTrailingDistance').value) || 5;
    }
    
    if (document.getElementById('presetBreakeven').checked) {
        order.breakeven = true;
        order.breakeven_profit = parseFloat(document.getElementById('presetBreakevenProfit').value) || 5;
    }
    
    if (orderType === 'limit') {
        const limitPrice = parseFloat(document.getElementById('limitPrice').value);
        
        if (!limitPrice) {
            showNotification('Please enter limit price', 'error');
            return;
        }
        
        // Валидация лимитных ордеров
        if (type === 'buy' && limitPrice >= currentAsk) {
            showNotification('Buy Limit price must be below current Ask price', 'error');
            return;
        }
        if (type === 'sell' && limitPrice <= currentBid) {
            showNotification('Sell Limit price must be above current Bid price', 'error');
            return;
        }
        
        // Добавляем параметры для лимитного ордера
        order.order_type = type === 'buy' ? 'buy_limit' : 'sell_limit';
        order.price = limitPrice;
    } else {
        order.order_type = 'market';  // Для рыночных ордеров
    }
    
    ws.send(JSON.stringify(order));
}
function handleExecution(data) {
            if (data.success) {
                showNotification(`Order executed: ${data.type} ${data.volume} ${data.symbol}`, 'success');
                
                // Request positions update
                ws.send(JSON.stringify({
                    type: 'request',
                    data: 'positions'
                }));
            } else {
                showNotification(`Order failed: ${data.error}`, 'error');
            }
        }

        // Close position
        function closePosition(positionId) {
            if (!isConnected) {
                showNotification('Not connected to server', 'error');
                return;
            }
            
                     ws.send(JSON.stringify({
                    type: 'close',
                    positionId: positionId
                }));
            }
        
        // Close all positions
        function closeAllPositions() {
            if (!confirm('Close all positions?')) return;
            
            if (!isConnected) {
                showNotification('Not connected to server', 'error');
                return;
            }
            
            ws.send(JSON.stringify({
                type: 'closeAll'
            }));
        }

        // Close all profitable positions
        function closeAllProfitable() {
            if (!confirm('Close all profitable positions?')) return;
            
            if (!isConnected) {
                showNotification('Not connected to server', 'error');
                return;
            }
            
            const profitableIds = positionsData
                .filter(p => p.profit > 0)
                .map(p => p.id);
            
            ws.send(JSON.stringify({
                type: 'closeMultiple',
                positionIds: profitableIds
            }));
        }

        // Close all losing positions
        function closeAllLosing() {
            if (!confirm('Close all losing positions?')) return;
            
            if (!isConnected) {
                showNotification('Not connected to server', 'error');
                return;
            }
            
            const losingIds = positionsData
                .filter(p => p.profit < 0)
                .map(p => p.id);
            
            ws.send(JSON.stringify({
                type: 'closeMultiple',
                positionIds: losingIds
            }));
        }

        // Switch tabs
        function switchTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.tab-section').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Remove active from all tab buttons
            document.querySelectorAll('.panel-tab').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Show selected tab
            document.getElementById(tabName + '-tab').classList.add('active');
            
            // Set active button
            event.target.classList.add('active');
        }

        // Change symbol
     function changeSymbol() {
    currentSymbol = document.getElementById('symbolSelect').value;
    const brokerSymbol = getBrokerSymbol(currentSymbol);  // Используем функцию
    
    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
            type: 'subscribe',
            symbol: brokerSymbol
        }));
        
        requestChartData();
    }
}
// Функция для получения символа с правильным суффиксом
function getBrokerSymbol(symbol) {
    // Криптовалюты - БЕЗ суффикса
    if (symbol.includes('BTC') || symbol.includes('ETH')) {
        return symbol;
    }
    // Форекс и металлы - С суффиксом
    return symbol + '+';
}
        // Change timeframe
        function changeTimeframe(tf) {
            currentTimeframe = tf;
            
            // Update button states
            document.querySelectorAll('.tf-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Request new chart data
            requestChartData();
        }

        // Request chart data
        function requestChartData() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'chart',
                    symbol: currentSymbol,
                    timeframe: currentTimeframe,
                    count: 500
                }));
                
                // Show loader
                document.getElementById('chartLoader').classList.add('active');
            }
        }

        // Update chart with new data
        function updateChart(candles) {
            chartData = candles || generateDemoCandles();
            document.getElementById('chartLoader').classList.remove('active');
            
            // Calculate visible range
            calculatePriceRange();
            
            // Redraw chart
            drawChart();
            // Update indicators with new data
            updateAllIndicators();
        }

        // Generate demo candles (fallback)
        function generateDemoCandles() {
            const candles = [];
            let basePrice = currentSymbol.includes('BTC') ? 115000 : 1.08000;
            let priceVariation = currentSymbol.includes('BTC') ? 1000 : 0.001;
            
            for (let i = 0; i < 200; i++) {
                const open = basePrice + (Math.random() - 0.5) * priceVariation;
                const close = open + (Math.random() - 0.5) * priceVariation;
                const high = Math.max(open, close) + Math.random() * priceVariation * 0.5;
                const low = Math.min(open, close) - Math.random() * priceVariation * 0.5;
                
                candles.push({
                    time: new Date(Date.now() - (200 - i) * 3600000),
                    open: open,
                    high: high,
                    low: low,
                    close: close,
                    volume: Math.random() * 1000
                });
                
                basePrice = close;
            }
            
            return candles;
        }

        // Update last candle with tick data
        function updateLastCandle(tickData) {
            if (chartData.length > 0 && tickData.symbol === currentSymbol) {
                const lastCandle = chartData[chartData.length - 1];
                lastCandle.close = tickData.bid;
                lastCandle.high = Math.max(lastCandle.high, tickData.bid);
                lastCandle.low = Math.min(lastCandle.low, tickData.bid);
                
                // Redraw chart if visible
                if (scrollOffset === 0) {
                    drawChart();
                }
            }
        }

 function calculatePriceRange() {
    if (!chartData || chartData.length === 0) {
        priceMin = 1.0;
        priceMax = 1.1;
        priceRange = 0.1;
        return;
    }
    
    // Update max scroll
    maxScroll = Math.max(0, chartData.length - visibleCandles);
    
    const startIdx = Math.max(0, chartData.length - visibleCandles - scrollOffset);
    const endIdx = Math.min(chartData.length, startIdx + visibleCandles);
    
    let tempMin = Infinity;
    let tempMax = -Infinity;
    
    for (let i = startIdx; i < endIdx; i++) {
        const candle = chartData[i];
        if (candle && typeof candle.low === 'number' && typeof candle.high === 'number' 
            && !isNaN(candle.low) && !isNaN(candle.high)) {
            tempMin = Math.min(tempMin, candle.low);
            tempMax = Math.max(tempMax, candle.high);
        }
    }
    
    // Если не нашли валидных значений, используем дефолтные
    if (tempMin === Infinity || tempMax === -Infinity) {
        priceMin = currentBid > 0 ? currentBid * 0.99 : 1.0;
        priceMax = currentBid > 0 ? currentBid * 1.01 : 1.1;
    } else {
        priceMin = tempMin;
        priceMax = tempMax;
    }
    
    // Include current price in range
    if (currentBid > 0 && !isNaN(currentBid)) {
        priceMin = Math.min(priceMin, currentBid);
        priceMax = Math.max(priceMax, currentBid);
    }
    
    // Add padding
    const padding = (priceMax - priceMin) * 0.1;
    priceMin -= padding;
    priceMax += padding;
    priceRange = priceMax - priceMin;
    
    // Финальная проверка
    if (!isFinite(priceRange) || priceRange <= 0) {
        priceRange = 0.1;
        priceMax = priceMin + priceRange;
    }
}

// Initialize chart
function initChart() {
    canvas = document.getElementById('tradingChart');
    ctx = canvas.getContext('2d');
    
    // УБИРАЕМ ResizeObserver - он создает конфликт с window.resize
    // Размеры будут управляться через window.resize в window.load
    
    // Add event listeners for chart
    canvas.addEventListener('mousemove', handleMouseMove);
    canvas.addEventListener('mousedown', handleMouseDown);
    canvas.addEventListener('mouseup', handleMouseUp);
    canvas.addEventListener('mouseleave', handleMouseLeave);
    canvas.addEventListener('wheel', handleMouseWheel);
    canvas.addEventListener('dblclick', handleDoubleClick);
    
    const yAxisHandle = document.getElementById('yAxisHandle');
    const xAxisHandle = document.getElementById('xAxisHandle');
    
    yAxisHandle.addEventListener('mousedown', handleYAxisMouseDown);
    xAxisHandle.addEventListener('mousedown', handleXAxisMouseDown);
    
    document.addEventListener('mousemove', handleAxisMouseMove);
    document.addEventListener('mouseup', handleAxisMouseUp);
}
// Panel resize functionality
function initPanelResize() {
    const resizer = document.getElementById('panelResizer');
    const positionsPanel = document.querySelector('.positions-panel'); // Изменено
    const chartContainer = document.querySelector('.chart-container');
    
    if (!resizer || !positionsPanel) return; // Добавлена проверка
    
    let isResizing = false;
    let startY = 0;
    let startHeight = 0;
    
    resizer.addEventListener('mousedown', (e) => {
        isResizing = true;
        startY = e.clientY;
        startHeight = positionsPanel.offsetHeight;
        
        e.preventDefault();
        document.body.style.userSelect = 'none';
        document.body.style.cursor = 'ns-resize';
    });
    
    document.addEventListener('mousemove', (e) => {
        if (!isResizing) return;
        
        const deltaY = startY - e.clientY;
        const newHeight = Math.min(
            Math.max(150, startHeight + deltaY),
            window.innerHeight * 0.6
        );
        
        positionsPanel.style.height = newHeight + 'px';
        positionsPanel.style.flex = 'none'; // Важно!
        
        // Пересчитываем размер canvas
        if (canvas && canvas.parentElement) {
            resizeCanvas();
        }
    });
    
    document.addEventListener('mouseup', () => {
        if (isResizing) {
            isResizing = false;
            document.body.style.userSelect = '';
            document.body.style.cursor = '';
        }
    });
}
function resizeCanvas() {
    const container = canvas.parentElement;
    if (!container) return;
    
    const newWidth = container.offsetWidth;
    const newHeight = container.offsetHeight;
    
    // Проверяем, действительно ли изменился размер
    if (canvas.width === newWidth && canvas.height === newHeight) {
        return; 
    }
    
    canvas.width = newWidth;
    canvas.height = newHeight;
    
    chartWidth = canvas.width;
    chartHeight = canvas.height;
    
    const availableWidth = chartWidth - 60 - chartPadding;
    visibleCandles = Math.floor(availableWidth / (candleWidth + candleSpacing));
    
    // Вызываем drawChart только если есть данные
    if (chartData && chartData.length > 0) {
        calculatePriceRange();
        drawChart();
    }
}
// Draw chart
function drawChart() {
    if (!ctx || chartData.length === 0) return;
    
    // Clear canvas
    ctx.clearRect(0, 0, chartWidth, chartHeight);
    
    // Draw background
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg-primary');
    ctx.fillRect(0, 0, chartWidth, chartHeight);
    
    // Draw grid
    drawGrid();
    
    // Draw candles
    drawCandles();
    
    // Draw current price line
    drawCurrentPriceLine();
    
    // Draw positions
    drawPositions();
    
    // Draw drawings
    drawAllDrawings();
    
    // Draw pending orders
    drawPendingOrders();
    
    // Draw price axis
    drawPriceAxis();
    
    // Draw time axis
    drawTimeAxis();
    
    // Draw crosshair if active
    if (selectedTool === 'crosshair') {
        drawCrosshair();
    }
    // Update indicators with current visible range
if (Object.keys(activeIndicators).length > 0) {
    for (const [type, indicator] of Object.entries(activeIndicators)) {
        if (indicator.enabled && indicator.iframe.contentWindow) {
            // Send visible range to indicator
            indicator.iframe.contentWindow.postMessage({
                type: 'updateView',
                startIdx: Math.max(0, chartData.length - visibleCandles - scrollOffset),
                endIdx: chartData.length - scrollOffset,
                priceMin: priceMin,
                priceMax: priceMax,
                width: chartWidth - 60,
                height: chartHeight - 45
            }, '*');
        }
    }
}
}
function drawCurrentPriceLine() {
    if (!document.getElementById('showPriceLine').checked || currentBid <= 0) return;
    
    const y = priceToY(currentBid);
    
    // Draw line
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent-primary');
    ctx.lineWidth = 2;
    ctx.setLineDash([10, 5]);
    
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(chartWidth - 60, y);
    ctx.stroke();
    
    // Draw price label
    ctx.setLineDash([]);
    const labelWidth = 80;
    const labelHeight = 24;
    
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent-primary');
    ctx.fillRect(chartWidth - 60, y - labelHeight/2, labelWidth, labelHeight);
    
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg-primary');
    ctx.font = 'bold 12px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(formatPrice(currentBid), chartWidth - 20, y + 4);
}

// Draw grid
function drawGrid() {            if (!document.getElementById('showGrid').checked) return;
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            
            // Horizontal lines
            for (let i = 0; i <= 10; i++) {
                const y = (chartHeight - 30) * (i / 10) + 15;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(chartWidth - 60, y);
                ctx.stroke();
            }
            
            // Vertical lines
            const gridStep = Math.ceil(visibleCandles / 10);
            for (let i = 0; i < visibleCandles; i += gridStep) {
                const x = i * (candleWidth + candleSpacing) + candleWidth / 2;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, chartHeight - 30);
                ctx.stroke();
            }
        }

       function drawCandles() {
    const startIdx = chartData.length - visibleCandles - scrollOffset;
    const endIdx = startIdx + visibleCandles;
    
    // Get theme colors
    const bullColor = getComputedStyle(document.documentElement).getPropertyValue('--candle-bull');
    const bearColor = getComputedStyle(document.documentElement).getPropertyValue('--candle-bear');
    const wickColor = getComputedStyle(document.documentElement).getPropertyValue('--candle-wick');
    
    for (let i = startIdx; i < endIdx; i++) {
        // Проверяем что индекс в пределах данных
        if (i < 0 || i >= chartData.length) continue;
        
        const candle = chartData[i];
        const x = (i - startIdx) * (candleWidth + candleSpacing);
        
        // Calculate Y positions
        const yOpen = priceToY(candle.open);
        const yClose = priceToY(candle.close);
        const yHigh = priceToY(candle.high);
        const yLow = priceToY(candle.low);
        
        // Set color
        const bullish = candle.close >= candle.open;
        
        // Draw wick
        ctx.strokeStyle = wickColor;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x + candleWidth / 2, yHigh);
        ctx.lineTo(x + candleWidth / 2, yLow);
        ctx.stroke();
        
        // Draw body
        const bodyHeight = Math.abs(yClose - yOpen) || 1;
        const bodyY = Math.min(yOpen, yClose);
        
        ctx.fillStyle = bullish ? bullColor : bearColor;
        ctx.fillRect(x, bodyY, candleWidth, bodyHeight);
        
        // Add subtle glow for neon/cyberpunk themes
        if (currentTheme === 'neon' || currentTheme === 'cyberpunk') {
            ctx.shadowColor = bullish ? bullColor : bearColor;
            ctx.shadowBlur = 3;
            ctx.fillRect(x, bodyY, candleWidth, bodyHeight);
            ctx.shadowBlur = 0;
        }
    }
    
    // Рисуем линию будущего времени
    const lastCandleX = (chartData.length - 1 - startIdx) * (candleWidth + candleSpacing) + candleWidth;
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
    ctx.lineWidth = 1;
    ctx.setLineDash([5, 5]);
    ctx.beginPath();
    ctx.moveTo(lastCandleX + candleSpacing, 0);
    ctx.lineTo(lastCandleX + candleSpacing, chartHeight - 30);
    ctx.stroke();
    ctx.setLineDash([]);
    
    // Update OHLC display
    if (chartData.length > 0 && scrollOffset >= 0 && scrollOffset < chartData.length) {
        const lastCandle = chartData[chartData.length - 1 - scrollOffset];
        if (lastCandle) {
            document.getElementById('ohlcOpen').textContent = formatPrice(lastCandle.open);
            document.getElementById('ohlcHigh').textContent = formatPrice(lastCandle.high);
            document.getElementById('ohlcLow').textContent = formatPrice(lastCandle.low);
            document.getElementById('ohlcClose').textContent = formatPrice(lastCandle.close);
        }
    }
}
        // Draw positions on chart with profit display
        function drawPositions() {
            const filteredPositions = positionsData.filter(pos => pos.symbol === currentSymbol);
            
            filteredPositions.forEach(pos => {
                const isHovered = hoveredPosition === pos.id;
                const lineWidth = isHovered ? 3 : 2;
                const opacity = isHovered ? 1 : 0.8;
                const entryY = priceToY(pos.openPrice);
                const isBuy = pos.type === 'buy';
                
                // Draw entry line
                ctx.strokeStyle = isBuy ? `rgba(34, 197, 94, ${opacity})` : `rgba(239, 68, 68, ${opacity})`;
                ctx.lineWidth = lineWidth;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(0, entryY);
                ctx.lineTo(chartWidth - 60, entryY);
                ctx.stroke();
                
                // Entry label
                ctx.setLineDash([]);
                ctx.fillStyle = isBuy ? 'rgba(34, 197, 94, 0.9)' : 'rgba(239, 68, 68, 0.9)';
                ctx.fillRect(chartWidth - 60, entryY - 12, 60, 24);
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 11px sans-serif';
                ctx.textAlign = 'right';
                ctx.fillText(formatPrice(pos.openPrice), chartWidth - 5, entryY + 3);
                
                // Position info with dollar profit
                const profitText = `${isBuy ? 'BUY' : 'SELL'} ${pos.volume} | P/L: $${pos.profit.toFixed(2)}`;
                const textWidth = ctx.measureText(profitText).width + 20;
                ctx.fillStyle = isBuy ? 'rgba(34, 197, 94, 0.8)' : 'rgba(239, 68, 68, 0.8)';
                ctx.fillRect(0, entryY - 12, textWidth, 24);
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 11px sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText(profitText, 10, entryY + 3);

                // Draw SL line with dollar value
                if (pos.sl) {
                    const slY = priceToY(pos.sl);
                    const slDollar = calculateDollarValueFromPriceDiff(pos.openPrice, pos.sl, pos.volume, pos.symbol);
                    
                    ctx.fillStyle = `rgba(239, 68, 68, 0.05)`;
                    ctx.fillRect(0, Math.min(entryY, slY), chartWidth - 60, Math.abs(slY - entryY));
                    
                    ctx.strokeStyle = `rgba(239, 68, 68, ${opacity * 0.7})`;
                    ctx.lineWidth = 1;
                    ctx.setLineDash([3, 3]);
                    ctx.beginPath();
                    ctx.moveTo(0, slY);
                    ctx.lineTo(chartWidth - 60, slY);
                    ctx.stroke();
                    
                    ctx.setLineDash([]);
                    ctx.fillStyle = 'rgba(239, 68, 68, 0.8)';
                    ctx.fillRect(chartWidth - 100, slY - 10, 90, 20);
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(`SL -$${slDollar.toFixed(2)}`, chartWidth - 55, slY + 3);
                }
                
                // Draw TP line with dollar value
                if (pos.tp) {
                    const tpY = priceToY(pos.tp);
                    const tpDollar = calculateDollarValueFromPriceDiff(pos.openPrice, pos.tp, pos.volume, pos.symbol);

                    ctx.fillStyle = `rgba(34, 197, 94, 0.05)`;
                    ctx.fillRect(0, Math.min(entryY, tpY), chartWidth - 60, Math.abs(tpY - entryY));

                    ctx.strokeStyle = `rgba(34, 197, 94, ${opacity * 0.7})`;
                    ctx.lineWidth = 1;
                    ctx.setLineDash([3, 3]);
                    ctx.beginPath();
                    ctx.moveTo(0, tpY);
                    ctx.lineTo(chartWidth - 60, tpY);
                    ctx.stroke();
                    
                    ctx.setLineDash([]);
                    ctx.fillStyle = 'rgba(34, 197, 94, 0.8)';
                    ctx.fillRect(chartWidth - 100, tpY - 10, 90, 20);
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(`TP +$${tpDollar.toFixed(2)}`, chartWidth - 55, tpY + 3);
                }
            });
        }

        // Drawing tools functions
        function selectTool(tool) {
            selectedTool = tool;
            drawingTool = null;
            
            // Update button states
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            const clickedBtn = event.target;
            clickedBtn.classList.add('active');
            
            // Hide drawing tools panel
            document.getElementById('drawingToolsPanel').classList.remove('active');
            
            // Update cursor
            canvas.style.cursor = tool === 'crosshair' ? 'crosshair' : 'default';
            
            drawChart();
        }

        function selectDrawingTool(tool) {
            drawingTool = tool;
            selectedTool = 'drawing';
            
            // Update button states
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Show drawing tools panel
            if (tool !== 'clear') {
                document.getElementById('drawingToolsPanel').classList.add('active');
            }
            
            canvas.style.cursor = 'crosshair';
        }

        function selectDrawingColor(color) {
            drawingColor = color;
            
            // Update color selection
            document.querySelectorAll('.color-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            event.target.classList.add('selected');
        }

        function clearAllDrawings() {
            if (confirm('Clear all drawings?')) {
                drawings = [];
                drawChart();
            }
        }
function startPendingOrder(type) {
    pendingOrderMode = true;
    pendingOrderType = type;
    pendingOrderStep = 'price';
    canvas.style.cursor = 'crosshair';
        // Сбрасываем другие инструменты
    selectedTool = 'pending_order';
    drawingTool = null;
    isDrawing = false;
    currentDrawing = null;
    
    // Обновляем активную кнопку
    document.querySelectorAll('.tool-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    event.target.classList.add('active');
    
    showNotification(`Click on chart to set ${type === 'buy_limit' ? 'Buy Limit' : 'Sell Limit'} price`, 'info');
}
// Функция установки цены лимитного ордера
function placePendingOrderOnChart(price) {
    if (!pendingOrderMode || !pendingOrderType) return;
    
    const volume = parseFloat(document.getElementById('lotSize').value) || 0.01;
    
    // Валидация цены для Buy/Sell Limit
    if (pendingOrderType === 'buy_limit' && price >= currentAsk) {
        showNotification('Buy Limit price must be below current Ask price', 'error');
        return;
    }
    if (pendingOrderType === 'sell_limit' && price <= currentBid) {
        showNotification('Sell Limit price must be above current Bid price', 'error');
        return;
    }
    
    // Создаем предпросмотр ордера
    pendingOrderPreview = {
        type: pendingOrderType,
        price: price,
        volume: volume,
        sl: null,
        tp: null,
        symbol: currentSymbol,
        id: 'preview_' + Date.now()
    };
    
    pendingOrderStep = 'sl';
    showNotification('Click to set Stop Loss (or press ESC to skip)', 'info');
    drawChart();
}

// Функция установки Stop Loss для лимитного ордера
function setPendingOrderSL(price) {
    if (!pendingOrderPreview) return;
    
    const isBuyLimit = pendingOrderPreview.type === 'buy_limit';
    
    // Валидация SL
    if (isBuyLimit && price >= pendingOrderPreview.price) {
        showNotification('Stop Loss for Buy Limit must be below order price', 'error');
        return;
    }
    if (!isBuyLimit && price <= pendingOrderPreview.price) {
        showNotification('Stop Loss for Sell Limit must be above order price', 'error');
        return;
    }
    
    pendingOrderPreview.sl = price;
    pendingOrderStep = 'tp';
    showNotification('Click to set Take Profit (or press ESC to skip)', 'info');
    drawChart();
}

// Функция установки Take Profit для лимитного ордера
function setPendingOrderTP(price) {
    if (!pendingOrderPreview) return;
    
    const isBuyLimit = pendingOrderPreview.type === 'buy_limit';
    
    // Валидация TP
    if (isBuyLimit && price <= pendingOrderPreview.price) {
        showNotification('Take Profit for Buy Limit must be above order price', 'error');
        return;
    }
    if (!isBuyLimit && price >= pendingOrderPreview.price) {
        showNotification('Take Profit for Sell Limit must be below order price', 'error');
        return;
    }
    
    pendingOrderPreview.tp = price;
    submitPendingOrder();
}

// Функция отправки лимитного ордера на сервер
function submitPendingOrder() {
    if (!pendingOrderPreview) return;
    
    const order = {
        type: 'order',  // Изменено с 'pending' на 'order'
        symbol: currentSymbol,
        action: pendingOrderPreview.type === 'buy_limit' ? 'buy' : 'sell',  // Извлекаем 'buy' или 'sell'
        order_type: pendingOrderPreview.type,  // 'buy_limit' или 'sell_limit'
        volume: pendingOrderPreview.volume,
        price: pendingOrderPreview.price  // Изменено с 'limit_price' на 'price'
    };
    
    // Добавляем SL если установлен
    if (pendingOrderPreview.sl) {
        const slDistance = Math.abs(pendingOrderPreview.price - pendingOrderPreview.sl);
        if (currentSymbol.includes('XAU')) {
            order.sl = slDistance * pendingOrderPreview.volume * 100;
        } else {
            order.sl = slDistance / pendingOrderPreview.volume;
        }
        order.sl_unit = 'dollar';
    }
    
    // Добавляем TP если установлен
    if (pendingOrderPreview.tp) {
        const tpDistance = Math.abs(pendingOrderPreview.tp - pendingOrderPreview.price);
        if (currentSymbol.includes('XAU')) {
            order.tp = tpDistance * pendingOrderPreview.volume * 100;
        } else {
            order.tp = tpDistance / pendingOrderPreview.volume;
        }
        order.tp_unit = 'dollar';
    }
    
    // Отправляем на сервер
    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify(order));
        showNotification('Limit order sent', 'success');
    }
    
    // Очищаем режим
    cancelPendingOrderMode();
}

// Функция отмены режима установки лимитного ордера
function cancelPendingOrderMode() {
    pendingOrderMode = false;
    pendingOrderType = null;
    pendingOrderPreview = null;
    pendingOrderStep = 'price';
    canvas.style.cursor = 'default';
    
    // Убираем активность с кнопок
    document.querySelectorAll('.tool-btn').forEach(btn => {
        if (btn.textContent === 'BL' || btn.textContent === 'SL') {
            btn.classList.remove('active');
        }
    });
    
    drawChart();
}
        function drawAllDrawings() {
            ctx.save();
            
            drawings.forEach(drawing => {
                ctx.strokeStyle = drawing.color || drawingColor;
                ctx.fillStyle = drawing.color || drawingColor;
                ctx.lineWidth = 2;
                
                switch (drawing.type) {
                    case 'line':
                        ctx.beginPath();
                        ctx.moveTo(drawing.x1, drawing.y1);
                        ctx.lineTo(drawing.x2, drawing.y2);
                        ctx.stroke();
                        break;
                        
                  case 'horizontal':
    const lineY = priceToY(drawing.price);  // Конвертируем цену в Y
    ctx.beginPath();
    ctx.moveTo(0, lineY);  // Используем lineY вместо drawing.y
    ctx.lineTo(chartWidth - 60, lineY);
    ctx.stroke();
    
    // Draw price label
    ctx.fillStyle = drawing.color || drawingColor;
    ctx.fillRect(chartWidth - 60, lineY - 10, 60, 20);
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg-primary');
    ctx.font = '11px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(formatPrice(drawing.price), chartWidth - 30, lineY + 3);  // Используем drawing.price
    break;
                        
                    case 'rectangle':
                        ctx.globalAlpha = 0.2;
                        ctx.fillRect(
                            Math.min(drawing.x1, drawing.x2),
                            Math.min(drawing.y1, drawing.y2),
                            Math.abs(drawing.x2 - drawing.x1),
                            Math.abs(drawing.y2 - drawing.y1)
                        );
                        ctx.globalAlpha = 1;
                        ctx.strokeRect(
                            Math.min(drawing.x1, drawing.x2),
                            Math.min(drawing.y1, drawing.y2),
                            Math.abs(drawing.x2 - drawing.x1),
                            Math.abs(drawing.y2 - drawing.y1)
                        );
                        break;
                        
                    case 'text':
                        ctx.font = '14px sans-serif';
                        ctx.fillText(drawing.text, drawing.x, drawing.y);
                        break;
                }
            });
            
            ctx.restore();
        }
        function checkDrawingHover() {
    hoveredDrawing = null;
    
    for (let i = drawings.length - 1; i >= 0; i--) {
        const drawing = drawings[i];
        
        if (drawing.type === 'horizontal') {
            const lineY = priceToY(drawing.price);
            // Проверяем попадание курсора на линию (±3 пикселя)
            if (Math.abs(mouseY - lineY) < 3 && mouseX < chartWidth - 60) {
                hoveredDrawing = i;
                canvas.style.cursor = 'pointer';
                return;
            }
        }
    }
}
// Функция отрисовки лимитных ордеров
// Функция отрисовки лимитных ордеров
function drawPendingOrders() {
    const style = getComputedStyle(document.documentElement);
    
    // Рисуем реальные pending ордера с сервера
    pendingOrdersData.forEach(order => {
        if (order.symbol !== currentSymbol) return;
        
        const y = priceToY(order.price);
        const isBuyLimit = order.type === 'buy_limit';
        
        // Цвета из темы
        const primaryColor = isBuyLimit ? style.getPropertyValue('--success') : style.getPropertyValue('--danger');
        
        // Легкая подсветка линии
        const gradient = ctx.createLinearGradient(0, y - 2, 0, y + 2);
        gradient.addColorStop(0, `${primaryColor}00`);
        gradient.addColorStop(0.5, `${primaryColor}30`);
        gradient.addColorStop(1, `${primaryColor}00`);
        ctx.fillStyle = gradient;
        ctx.fillRect(0, y - 2, chartWidth - 60, 4);
        
        // Основная линия ордера
        ctx.strokeStyle = primaryColor;
        ctx.lineWidth = 1.5;
        ctx.setLineDash([25, 8]);
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(chartWidth - 60, y);
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Метка ПОД ЛИНИЕЙ (смещение вниз на 5px от линии)
        const labelY = y + 25; // Позиция метки ниже линии
        const labelText = `${isBuyLimit ? 'BUY' : 'SELL'} LIMIT`;
        const volumeText = `${order.volume.toFixed(2)} lots`;
        const ticketText = `#${order.ticket}`;
        
        ctx.font = '11px sans-serif';
        const labelWidth = Math.max(
            ctx.measureText(labelText).width,
            ctx.measureText(volumeText).width
        ) + 25;
        
        // Полупрозрачный фон метки под линией
        ctx.fillStyle = `${style.getPropertyValue('--bg-panel')}ee`;
        ctx.fillRect(10, labelY - 15, labelWidth, 35);
        
        // Тонкая рамка метки
        ctx.strokeStyle = `${primaryColor}bb`;
        ctx.lineWidth = 1;
        ctx.strokeRect(10, labelY - 15, labelWidth, 35);
        
        // Линия-указатель от метки к ордеру
        ctx.strokeStyle = `${primaryColor}66`;
        ctx.lineWidth = 0.5;
        ctx.beginPath();
        ctx.moveTo(10 + labelWidth/2, labelY - 15);
        ctx.lineTo(10 + labelWidth/2, y);
        ctx.stroke();
        
        // Тексты в метке
        ctx.fillStyle = primaryColor;
        ctx.font = 'bold 11px sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText(labelText, 18, labelY);
        
        ctx.fillStyle = style.getPropertyValue('--text-secondary');
        ctx.font = '10px sans-serif';
        ctx.fillText(volumeText, 18, labelY + 12);
        
        ctx.fillStyle = `${primaryColor}99`;
        ctx.font = '9px sans-serif';
        ctx.fillText(ticketText, 18, labelY - 5);
        
        // ЦЕНА СПРАВА (сдвинута левее чтобы не обрезалась)
        const priceLabel = formatPrice(order.price);
        ctx.font = 'bold 12px sans-serif';
        const priceWidth = ctx.measureText(priceLabel).width + 20;
        
        // Фон для цены (сдвинут на 70px от края)
        ctx.fillStyle = primaryColor;
        ctx.fillRect(chartWidth - 70 - priceWidth, y - 10, priceWidth, 20);
        
        // Текст цены
        ctx.fillStyle = style.getPropertyValue('--bg-primary');
        ctx.textAlign = 'right';
        ctx.fillText(priceLabel, chartWidth - 75, y + 3);
        ctx.textAlign = 'left';
        
        // SL/TP линии если есть (очень тонкие)
        if (order.sl) {
            const slY = priceToY(order.sl);
            ctx.strokeStyle = `${style.getPropertyValue('--danger')}25`;
            ctx.lineWidth = 0.5;
            ctx.setLineDash([5, 15]);
            ctx.beginPath();
            ctx.moveTo(0, slY);
            ctx.lineTo(chartWidth - 60, slY);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        if (order.tp) {
            const tpY = priceToY(order.tp);
            ctx.strokeStyle = `${style.getPropertyValue('--success')}25`;
            ctx.lineWidth = 0.5;
            ctx.setLineDash([5, 15]);
            ctx.beginPath();
            ctx.moveTo(0, tpY);
            ctx.lineTo(chartWidth - 60, tpY);
            ctx.stroke();
            ctx.setLineDash([]);
        }
    });
    
    // Также рисуем из старого массива для совместимости
    pendingOrders.forEach(order => {
        if (order.symbol !== currentSymbol) return;
        
        const y = priceToY(order.price);
        const isBuyLimit = order.type === 'buy_limit';
        const primaryColor = isBuyLimit ? style.getPropertyValue('--success') : style.getPropertyValue('--danger');
        
        // Минималистичная линия
        ctx.strokeStyle = primaryColor;
        ctx.lineWidth = 1.5;
        ctx.setLineDash([25, 8]);
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(chartWidth - 60, y);
        ctx.stroke();
        ctx.setLineDash([]);
    });
    
    // Предпросмотр нового ордера
    if (pendingOrderPreview) {
        const y = priceToY(pendingOrderPreview.price);
        const isBuyLimit = pendingOrderPreview.type === 'buy_limit';
        const primaryColor = style.getPropertyValue('--accent-primary');
        
        // Пульсирующая линия
        ctx.strokeStyle = primaryColor;
        ctx.lineWidth = 2;
        ctx.setLineDash([15, 5]);
        ctx.globalAlpha = 0.9;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(chartWidth - 60, y);
        ctx.stroke();
        ctx.globalAlpha = 1;
        ctx.setLineDash([]);
        
        // Метка по центру
        const labelText = `PLACING ${isBuyLimit ? 'BUY' : 'SELL'} LIMIT`;
        ctx.font = 'bold 12px sans-serif';
        const textWidth = ctx.measureText(labelText).width + 25;
        
        ctx.fillStyle = `${style.getPropertyValue('--bg-panel')}f5`;
        ctx.fillRect(chartWidth/2 - textWidth/2, y + 10, textWidth, 25);
        
        ctx.strokeStyle = primaryColor;
        ctx.lineWidth = 1.5;
        ctx.strokeRect(chartWidth/2 - textWidth/2, y + 10, textWidth, 25);
        
        ctx.fillStyle = primaryColor;
        ctx.textAlign = 'center';
        ctx.fillText(labelText, chartWidth/2, y + 27);
        ctx.textAlign = 'left';
    }
}
        // Handle double click for adding SL/TP
        function handleDoubleClick(event) {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            // Check if clicking in chart area
            if (x > chartWidth - 60 || y > chartHeight - 30) return;
            
            // Find nearest position
            const clickedPrice = yToPrice(y);
            const nearestPosition = findNearestPosition(clickedPrice);
            
            if (nearestPosition) {
                const pos = positionsData.find(p => p.id === nearestPosition);
                if (!pos) return;
                
                const isBuy = pos.type === 'buy';
                const isAboveEntry = clickedPrice > pos.openPrice;
                
                // Determine if setting SL or TP based on position
                if ((isBuy && !isAboveEntry) || (!isBuy && isAboveEntry)) {
                    // Set Stop Loss
                    if (confirm(`Set Stop Loss at ${formatPrice(clickedPrice)}?`)) {
                        const slPips = Math.abs(pos.openPrice - clickedPrice) / 0.0001;
                        ws.send(JSON.stringify({
                            type: 'modify',
                            positionId: nearestPosition,
                            sl: slPips,
                            tp: null
                        }));
                    }
                } else {
                    // Set Take Profit
                    if (confirm(`Set Take Profit at ${formatPrice(clickedPrice)}?`)) {
                        const tpPips = Math.abs(clickedPrice - pos.openPrice) / 0.0001;
                        ws.send(JSON.stringify({
                            type: 'modify',
                            positionId: nearestPosition,
                            sl: null,
                            tp: tpPips
                        }));
                    }
                }
            }
        }

        function findNearestPosition(price) {
            const filteredPositions = positionsData.filter(pos => pos.symbol === currentSymbol);
            if (filteredPositions.length === 0) return null;
            
            let nearest = filteredPositions[0].id;
            let minDistance = Math.abs(price - filteredPositions[0].openPrice);
            
            filteredPositions.forEach(pos => {
                const distance = Math.abs(price - pos.openPrice);
                if (distance < minDistance) {
                    minDistance = distance;
                    nearest = pos.id;
                }
            });
            
            return nearest;
        }

        // Draw price axis
        function drawPriceAxis() {
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-secondary');
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'right';
            
            for (let i = 0; i <= 10; i++) {
                const price = priceMin + (priceRange * (1 - i / 10));
                const y = (chartHeight - 30) * (i / 10) + 15;
                
                ctx.fillText(formatPrice(price), chartWidth - 5, y + 3);
            }
        }

        // Draw time axis with correct time formatting
        function drawTimeAxis() {
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-secondary');
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'center';
            
            const startIdx = Math.max(0, chartData.length - visibleCandles - scrollOffset);
            const endIdx = Math.min(chartData.length, startIdx + visibleCandles);
            const step = Math.ceil(visibleCandles / 10);
            
            for (let i = startIdx; i < endIdx; i += step) {
                const candle = chartData[i];
                if (!candle) continue;
                
                const x = (i - startIdx) * (candleWidth + candleSpacing) + candleWidth / 2;
                const time = new Date(candle.time);
                
                let timeStr;
                // Format time based on timeframe
                if (currentTimeframe === 'M1' || currentTimeframe === 'M5' || currentTimeframe === 'M15' || currentTimeframe === 'M30') {
                    // For minute timeframes, show time
                    timeStr = time.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false });
                } else if (currentTimeframe === 'H1' || currentTimeframe === 'H4') {
                    // For hour timeframes, show date and time
                    const month = time.toLocaleDateString('en-US', { month: 'short' });
                    const day = time.getDate();
                    const hour = time.toLocaleTimeString('en-US', { hour: '2-digit', hour12: false });
                    timeStr = `${month} ${day} ${hour}:00`;
                } else if (currentTimeframe === 'D1') {
                    // For daily timeframe, show date
                    timeStr = time.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                } else if (currentTimeframe === 'W1') {
                    // For weekly timeframe, show week start date
                    timeStr = time.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                } else if (currentTimeframe === 'MN') {
                    // For monthly timeframe, show month and year
                    timeStr = time.toLocaleDateString('en-US', { month: 'short', year: '2-digit' });
                }
                
                ctx.fillText(timeStr, x, chartHeight - 10);
            }
        }

        // Convert price to Y coordinate
        function priceToY(price) {
            return ((priceMax - price) / priceRange) * (chartHeight - 45) + 15;
        }

        // Convert Y coordinate to price
        function yToPrice(y) {
            return priceMax - ((y - 15) / (chartHeight - 45)) * priceRange;
        }

        // Handle Y axis resize (vertical zoom)
        function handleYAxisMouseDown(event) {
            isResizingYAxis = true;
            yAxisStartY = event.clientY;
            priceRangeStart = priceRange;
            event.preventDefault();
        }

        // Handle X axis resize (horizontal zoom)
        function handleXAxisMouseDown(event) {
            isResizingXAxis = true;
            xAxisStartX = event.clientX;
            candleWidthStart = candleWidth;
            event.preventDefault();
        }

        // Handle axis mouse move
        function handleAxisMouseMove(event) {
            if (isResizingYAxis) {
                const deltaY = event.clientY - yAxisStartY;
                const scaleFactor = 1 + (deltaY / 200);
                
                const newRange = priceRangeStart * scaleFactor;
                const center = (priceMax + priceMin) / 2;
                
                priceRange = Math.max(newRange, 0.00001);
                priceMax = center + priceRange / 2;
                priceMin = center - priceRange / 2;
                
                drawChart();
            }
            
            if (isResizingXAxis) {
                const deltaX = event.clientX - xAxisStartX;
                const scaleFactor = 1 - (deltaX / 200);
                
                const newCandleWidth = candleWidthStart * scaleFactor;
                candleWidth = Math.max(2, Math.min(30, newCandleWidth));
                
                const availableWidth = chartWidth - 60 - chartPadding;
                visibleCandles = Math.floor(availableWidth / (candleWidth + candleSpacing));
                
                calculatePriceRange();
                drawChart();
            }
        }

        // Handle axis mouse up
        function handleAxisMouseUp(event) {
            isResizingYAxis = false;
            isResizingXAxis = false;
        }

        // Handle mouse wheel
        function handleMouseWheel(event) {
            event.preventDefault();
            
            const scrollSpeed = 5;
            
            if (event.ctrlKey || event.metaKey) {
                // Vertical zoom (already implemented)
                const delta = event.deltaY > 0 ? -0.1 : 0.1;
                const center = (priceMax + priceMin) / 2;
                const newRange = priceRange * (1 + delta);
                
                priceMax = center + newRange / 2;
                priceMin = center - newRange / 2;
                priceRange = newRange;
                
                drawChart();
            } else if (event.shiftKey) {
                // Horizontal zoom (already implemented)
                const delta = event.deltaY > 0 ? -1 : 1;
                candleWidth = Math.max(2, Math.min(30, candleWidth + delta));
                const availableWidth = chartWidth - 60 - chartPadding;
                visibleCandles = Math.floor(availableWidth / (candleWidth + candleSpacing));
                calculatePriceRange();
                drawChart();
            } else {
                // Scroll
                const delta = event.deltaY > 0 ? scrollSpeed : -scrollSpeed;
                scrollOffset = Math.max(-50, scrollOffset + delta);
                calculatePriceRange();
                drawChart();
            }
        }

       // Handle mouse move
function handleMouseMove(event) {
    const rect = canvas.getBoundingClientRect();
    mouseX = event.clientX - rect.left;
    mouseY = event.clientY - rect.top;
    
    // --- НАЧАЛО НОВОГО БЛОКА ---
    // Если мы создаем новый SL/TP, перерисовываем график, чтобы показать фантомную линию
    if (draggingLine === 'entry') {
        drawChart(); // Перерисовываем график
        
        // Рисуем временную линию от цены входа до курсора
        const entryY = priceToY(draggedPosition.openPrice);
        const currentPrice = yToPrice(mouseY);
        const isBuy = draggedPosition.type === 'buy';
        
        // Определяем, это SL или TP, и задаем цвет
        let isStopLoss = (isBuy && mouseY > entryY) || (!isBuy && mouseY < entryY);
        ctx.strokeStyle = isStopLoss ? 'rgba(239, 68, 68, 0.7)' : 'rgba(34, 197, 94, 0.7)';
        
        ctx.lineWidth = 2;
        ctx.setLineDash([3, 3]);
        ctx.beginPath();
        ctx.moveTo(0, mouseY);
        ctx.lineTo(chartWidth - 60, mouseY);
        ctx.stroke();
        
        // Рисуем плашку с ценой
        const dollarValue = calculateDollarValueFromPriceDiff(draggedPosition.openPrice, currentPrice, draggedPosition.volume, draggedPosition.symbol);
        const labelText = isStopLoss ? `SL -$${dollarValue.toFixed(2)}` : `TP +$${dollarValue.toFixed(2)}`;
        
        ctx.setLineDash([]);
        ctx.fillStyle = isStopLoss ? 'rgba(239, 68, 68, 0.8)' : 'rgba(34, 197, 94, 0.8)';
        ctx.fillRect(chartWidth - 100, mouseY - 10, 90, 20);
        ctx.fillStyle = '#ffffff';
        ctx.font = '10px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(labelText, chartWidth - 55, mouseY + 3);

        return; // Выходим, чтобы не выполнялся остальной код функции
    }
    // --- КОНЕЦ НОВОГО БЛОКА ---

    if (draggingLine && (draggingLine === 'sl' || draggingLine === 'tp')) {
        updateDraggedLine(yToPrice(mouseY));
        drawChart();
   } else if (isDragging) {
    if (selectedTool === 'cursor') {
        // Горизонтальный скролл (исправленное направление)
        const deltaX = event.clientX - dragStartX;
        const candlesDelta = Math.floor(deltaX / (candleWidth + candleSpacing));
        scrollOffset = Math.max(-50, Math.min(maxScroll, dragStartOffset + candlesDelta));
        
        // Вертикальное перемещение (исправленное направление)
        const deltaY = event.clientY - dragStartY;
        const priceDelta = (deltaY / chartHeight) * priceRange;
        const newCenter = dragStartPriceCenter + priceDelta;
        
        priceMax = newCenter + priceRange / 2;
        priceMin = newCenter - priceRange / 2;
        
        drawChart();
    }

    } else if (isDrawing && currentDrawing) {
        // Update current drawing
        switch (currentDrawing.type) {
            case 'line':
            case 'rectangle':
                currentDrawing.x2 = mouseX;
                currentDrawing.y2 = mouseY;
                break;
        }
        drawChart();
        drawCurrentDrawing();
    } else {
        checkHandleHover();
        checkDrawingHover();
        if (selectedTool === 'crosshair') {
            drawChart();
        }
    }
}

        function drawCurrentDrawing() {
            if (!currentDrawing) return;
            
            ctx.save();
            ctx.strokeStyle = drawingColor;
            ctx.fillStyle = drawingColor;
            ctx.lineWidth = 2;
            
            switch (currentDrawing.type) {
                case 'line':
                    ctx.beginPath();
                    ctx.moveTo(currentDrawing.x1, currentDrawing.y1);
                    ctx.lineTo(currentDrawing.x2, currentDrawing.y2);
                    ctx.stroke();
                    break;
                    
                case 'rectangle':
                    ctx.globalAlpha = 0.2;
                    ctx.fillRect(
                        Math.min(currentDrawing.x1, currentDrawing.x2),
                        Math.min(currentDrawing.y1, currentDrawing.y2),
                        Math.abs(currentDrawing.x2 - currentDrawing.x1),
                        Math.abs(currentDrawing.y2 - currentDrawing.y1)
                    );
                    ctx.globalAlpha = 1;
                    ctx.strokeRect(
                        Math.min(currentDrawing.x1, currentDrawing.x2),
                        Math.min(currentDrawing.y1, currentDrawing.y2),
                        Math.abs(currentDrawing.x2 - currentDrawing.x1),
                        Math.abs(currentDrawing.y2 - currentDrawing.y1)
                    );
                    break;
            }
            
            ctx.restore();
        }

        // Check if hovering over TP/SL handles or potential creation zones
        function checkHandleHover() {
            let cursorChanged = false;
            
            positionsData.filter(pos => pos.symbol === currentSymbol).forEach(pos => {
                const entryY = priceToY(pos.openPrice);
                
                // Check SL handle
                if (pos.sl) {
                    const slY = priceToY(pos.sl);
                    if (mouseX > chartWidth - 100 && mouseX < chartWidth - 60 &&
                        mouseY > slY - 10 && mouseY < slY + 10) {
                        canvas.style.cursor = 'ns-resize';
                        cursorChanged = true;
                    }
                }
                
                // Check TP handle
                if (pos.tp) {
                    const tpY = priceToY(pos.tp);
                    if (mouseX > chartWidth - 100 && mouseX < chartWidth - 60 &&
                        mouseY > tpY - 10 && mouseY < tpY + 10) {
                        canvas.style.cursor = 'ns-resize';
                        cursorChanged = true;
                    }
                }
                
                // Check potential SL/TP creation zones if hovering position
                if (hoveredPosition === pos.id) {
                    if (!pos.sl) {
                        const isBuy = pos.type === 'buy';
                        const potentialSlY = isBuy ? entryY + 50 : entryY - 50;
                        if (mouseX > chartWidth - 100 && mouseX < chartWidth - 60 &&
                            mouseY > potentialSlY - 20 && mouseY < potentialSlY + 20) {
                            canvas.style.cursor = 'grab';
                            cursorChanged = true;
                        }
                    }
                    
                    if (!pos.tp) {
                        const isBuy = pos.type === 'buy';
                        const potentialTpY = isBuy ? entryY - 50 : entryY + 50;
                        if (mouseX > chartWidth - 100 && mouseX < chartWidth - 60 &&
                            mouseY > potentialTpY - 20 && mouseY < potentialTpY + 20) {
                            canvas.style.cursor = 'grab';
                            cursorChanged = true;
                        }
                    }
                }
            });
            
            if (!cursorChanged && !isDragging && !isDrawing) {
                if (selectedTool === 'crosshair' || drawingTool) {
                    canvas.style.cursor = 'crosshair';
                } else {
                    canvas.style.cursor = 'default';
                }
            }
        }

        // Handle mouse down
function handleMouseDown(event) {
    const rect = canvas.getBoundingClientRect();
    mouseX = event.clientX - rect.left;
    mouseY = event.clientY - rect.top;
    
   if (event.detail === 2) { // Двойной клик
        for (let order of pendingOrders) {
            if (order.symbol !== currentSymbol) continue;
            
            const orderY = priceToY(order.price);
            // Проверяем попадание в область ордера
            if (mouseY > orderY - 15 && mouseY < orderY + 15 && mouseX < 400) {
                if (confirm(`Cancel ${order.type.replace('_', ' ')} order #${order.ticket}?`)) {
                    ws.send(JSON.stringify({
                        type: 'cancelOrder',
                        ticket: order.ticket
                    }));
                }
                event.preventDefault();
                return;
            }
        }
    }
    if (pendingOrderMode) {
        const clickedPrice = yToPrice(mouseY);
        
        if (pendingOrderStep === 'price') {
            placePendingOrderOnChart(clickedPrice);
        } else if (pendingOrderStep === 'sl') {
            setPendingOrderSL(clickedPrice);
        } else if (pendingOrderStep === 'tp') {
            setPendingOrderTP(clickedPrice);
        }
        
        event.preventDefault();
        return;
    }
    
    // Handle drawing tools
    if (drawingTool) {
        isDrawing = true;
        switch (drawingTool) {
            case 'line':
            case 'rectangle':
                currentDrawing = { type: drawingTool, x1: mouseX, y1: mouseY, x2: mouseX, y2: mouseY, color: drawingColor };
                break;
            case 'horizontal':
    drawings.push({ 
        type: 'horizontal', 
        price: yToPrice(mouseY),  // Изменили y на price
        color: drawingColor,
        id: Date.now()  // Добавили ID для удаления
    });
    drawChart();
    break;
            case 'text':
                const textOverlay = document.getElementById('textInputOverlay');
                const textField = document.getElementById('textInputField');
                textOverlay.style.left = mouseX + 'px';
                textOverlay.style.top = mouseY + 'px';
                textOverlay.classList.add('active');
                textField.value = '';
                textField.focus();
                textField.onkeydown = (e) => {
                    if (e.key === 'Enter') {
                        drawings.push({ type: 'text', text: textField.value, x: mouseX, y: mouseY, color: drawingColor });
                        textOverlay.classList.remove('active');
                        drawChart();
                    } else if (e.key === 'Escape') {
                        textOverlay.classList.remove('active');
                    }
                };
                break;
        }
        return;
    }
    
    // ... остальной код функции остается без изменений
    
    let handleClicked = false;
    
    // Check if clicking on existing TP/SL handles
    positionsData.filter(pos => pos.symbol === currentSymbol).forEach(pos => {
        if (handleClicked) return;
        
        if (pos.sl) {
            const slY = priceToY(pos.sl);
            if (mouseX > chartWidth - 100 && mouseX < chartWidth - 10 && mouseY > slY - 10 && mouseY < slY + 10) {
                draggingLine = 'sl';
                draggedPosition = pos;
                handleClicked = true;
            }
        }
        
        if (pos.tp) {
            const tpY = priceToY(pos.tp);
            if (mouseX > chartWidth - 100 && mouseX < chartWidth - 10 && mouseY > tpY - 10 && mouseY < tpY + 10) {
                draggingLine = 'tp';
                draggedPosition = pos;
                handleClicked = true;
            }
        }
    });

    // --- НАЧАЛО НОВОГО БЛОКА ---
    // Check if clicking on an entry line to CREATE a new SL/TP
    if (!handleClicked) {
        positionsData.filter(pos => pos.symbol === currentSymbol).forEach(pos => {
            if (handleClicked) return;

            const entryY = priceToY(pos.openPrice);
            // Проверяем, находится ли курсор очень близко к линии входа (по вертикали)
            if (mouseY > entryY - 5 && mouseY < entryY + 5) {
                // Запускаем новый тип перетаскивания для создания SL/TP
                draggingLine = 'entry'; 
                draggedPosition = pos;
                handleClicked = true;
                canvas.style.cursor = 'ns-resize'; // Меняем курсор на вертикальное изменение
            }
        });
    }
    // --- КОНЕЦ НОВОГО БЛОКА ---

    if (!handleClicked && selectedTool === 'cursor') {
    isDragging = true;
    dragStartX = event.clientX;
    dragStartY = event.clientY;  // ДОБАВИТЬ
    dragStartOffset = scrollOffset;
    dragStartPriceCenter = (priceMax + priceMin) / 2;  // ДОБАВИТЬ
    canvas.style.cursor = 'grabbing';
}
}

    // Handle mouse up
function handleMouseUp(event) {
    if (isDrawing && currentDrawing) {
        if (currentDrawing.type === 'line' || currentDrawing.type === 'rectangle') {
            drawings.push(currentDrawing);
            currentDrawing = null;
        }
        isDrawing = false;
        drawChart();
    }
    
    // --- НАЧАЛО ОБНОВЛЕННОГО БЛОКА ---
    if (draggingLine && draggedPosition) {
        const newPrice = yToPrice(mouseY);
        
        if (ws && ws.readyState === WebSocket.OPEN) {
            let modification = { type: 'modify', positionId: draggedPosition.id };
            
            if (draggingLine === 'entry') {
                // Логика для СОЗДАНИЯ нового SL/TP
                const entryPrice = draggedPosition.openPrice;
                const isBuy = draggedPosition.type === 'buy';

                if ((isBuy && newPrice < entryPrice) || (!isBuy && newPrice > entryPrice)) {
                    // Это Stop Loss
                    modification.sl_price = newPrice;
                } else {
                    // Это Take Profit
                    modification.tp_price = newPrice;
                }

            } else if (draggingLine === 'sl') {
                // Логика для ИЗМЕНЕНИЯ существующего SL
                modification.sl_price = newPrice;
            } else if (draggingLine === 'tp') {
                // Логика для ИЗМЕНЕНИЯ существующего TP
                modification.tp_price = newPrice;
            }
            
            ws.send(JSON.stringify(modification));
        }
        
        draggingLine = null;
        draggedPosition = null;
    }
    // --- КОНЕЦ ОБНОВЛЕННОГО БЛОКА ---
    
    isDragging = false;
    isDrawing = false;
    canvas.style.cursor = selectedTool === 'crosshair' ? 'crosshair' : 'default';
}

        // Handle mouse leave
function handleMouseLeave(event) {
    isDragging = false;
    isDrawing = false;
    currentDrawing = null;
    
    // --- ДОБАВЛЕННЫЙ КОД ---
    // Сбрасываем состояние перетаскивания линий, если мышь ушла с холста
    draggingLine = null;
    draggedPosition = null;
    // --- КОНЕЦ ДОБАВЛЕННОГО КОДА ---

    canvas.style.cursor = 'default';
}

        // Update dragged line preview
        function updateDraggedLine(newPrice) {
            if (draggedPosition && draggingLine) {
                // Calculate dollar value for display
                const pips = Math.abs(draggedPosition.openPrice - newPrice) / 0.0001;
                const dollarValue = calculateDollarFromPips(pips, draggedPosition.volume);
                
                // Show preview in real-time (this will be drawn in drawPositions)
                if (draggingLine === 'sl' || draggingLine === 'sl-create') {
                    draggedPosition.sl = newPrice;
                } else if (draggingLine === 'tp' || draggingLine === 'tp-create') {
                    draggedPosition.tp = newPrice;
                }
            }
        }

        // Draw crosshair
        function drawCrosshair() {
            if (mouseX < 0 || mouseX > chartWidth - 60 || mouseY < 15 || mouseY > chartHeight - 30) {
                return;
            }
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            
            // Horizontal line
            ctx.beginPath();
            ctx.moveTo(0, mouseY);
            ctx.lineTo(chartWidth - 60, mouseY);
            ctx.stroke();
            
            // Vertical line
            ctx.beginPath();
            ctx.moveTo(mouseX, 15);
            ctx.lineTo(mouseX, chartHeight - 30);
            ctx.stroke();
            
            ctx.setLineDash([]);
            
            // Price label
            const price = yToPrice(mouseY);
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg-secondary');
            ctx.fillRect(chartWidth - 60, mouseY - 10, 60, 20);
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-primary');
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'right';
            ctx.fillText(formatPrice(price), chartWidth - 5, mouseY + 3);
        }

        // Set lot size
        function setLot(value) {
            document.getElementById('lotSize').value = value;
        }
// Функция выбора типа ордера
function selectOrderType(type) {
    orderType = type;
    
    // Обновляем UI
    document.getElementById('marketOrderBtn').classList.toggle('active', type === 'market');
    document.getElementById('limitOrderBtn').classList.toggle('active', type === 'limit');
    
    // Показываем/скрываем поле для лимитной цены
    const limitPriceGroup = document.getElementById('limitPriceGroup');
    limitPriceGroup.style.display = type === 'limit' ? 'block' : 'none';
    
    // Обновляем текст на кнопках
    const buyButton = document.getElementById('buyButton');
    const sellButton = document.getElementById('sellButton');
    
    if (type === 'limit') {
        document.getElementById('buyButtonText').textContent = 'BUY LIMIT';
        document.getElementById('sellButtonText').textContent = 'SELL LIMIT';
        buyButton.classList.add('limit-order');
        sellButton.classList.add('limit-order');
        
        // Устанавливаем начальную лимитную цену
        setInitialLimitPrice();
    } else {
        document.getElementById('buyButtonText').textContent = 'BUY';
        document.getElementById('sellButtonText').textContent = 'SELL';
        buyButton.classList.remove('limit-order');
        sellButton.classList.remove('limit-order');
    }
}
// Установка начальной лимитной цены
function setInitialLimitPrice() {
    const limitPriceInput = document.getElementById('limitPrice');
    if (currentBid > 0) {
        limitPriceInput.value = formatPrice(currentBid);
        updateLimitPriceDistance();
    }
}
// Установка лимитной цены от текущей
function setLimitPriceFromCurrent(priceType) {
    const limitPriceInput = document.getElementById('limitPrice');
    if (priceType === 'bid' && currentBid > 0) {
        limitPriceInput.value = formatPrice(currentBid);
    } else if (priceType === 'ask' && currentAsk > 0) {
        limitPriceInput.value = formatPrice(currentAsk);
    }
    updateLimitPriceDistance();
}
// Обновление расстояния от текущей цены
function updateLimitPriceDistance() {
    const limitPrice = parseFloat(document.getElementById('limitPrice').value);
    if (!limitPrice || !currentBid) return;
    
    const distance = Math.abs(limitPrice - currentBid);
    const pips = calculatePipsFromPrice(distance);
    
    const distanceElement = document.getElementById('limitPriceDistance');
    if (limitPrice > currentBid) {
        distanceElement.textContent = `+${pips.toFixed(1)} pips above`;
        distanceElement.style.color = 'var(--success)';
    } else if (limitPrice < currentBid) {
        distanceElement.textContent = `${pips.toFixed(1)} pips below`;
        distanceElement.style.color = 'var(--danger)';
    } else {
        distanceElement.textContent = 'At current price';
        distanceElement.style.color = 'var(--text-secondary)';
    }
}
// Расчет пипсов из разницы цен
function calculatePipsFromPrice(priceDiff) {
    if (currentSymbol.includes('JPY')) {
        return priceDiff / 0.001; // Для JPY пар
    } else if (currentSymbol.includes('BTC') || currentSymbol.includes('XAU')) {
        return priceDiff; // Для крипты и золота в долларах
    } else {
        return priceDiff / 0.00001; // Для стандартных валютных пар (5 знаков)
    }
}
        // Theme management
function changeTheme(themeName) {
    if (!themes[themeName]) return;
    
    const theme = themes[themeName];
    const root = document.documentElement;
    
    // Apply theme colors
    for (const [key, value] of Object.entries(theme)) {
        root.style.setProperty(key, value);
    }
    
    // Update active theme button
    document.querySelectorAll('.theme-option').forEach(btn => {
        btn.classList.remove('active');
        btn.style.border = '2px solid var(--border)';
    });
    event.target.classList.add('active');
    event.target.style.border = '2px solid var(--accent-primary)';
    
    // Save preference
    currentTheme = themeName;
    localStorage.setItem('currentTheme', themeName);
    
    // Apply theme class for candle colors
    document.body.className = 'theme-' + themeName;
    
    // Отправляем тему всем активным индикаторам
    for (const type of Object.keys(activeIndicators)) {
        const indicator = activeIndicators[type];
        if (indicator.iframe && indicator.iframe.contentWindow) {
            indicator.iframe.contentWindow.postMessage({
                type: 'themeChange',
                theme: themeName
            }, '*');
        }
    }
    
    // Redraw chart with new colors
    drawChart();
    
    showNotification(`Theme changed to ${themeName}`, 'success');
}

        function updateChartSettings() {
            drawChart();
        }

        // Update connection status
        function updateConnectionStatus(connected) {
            const dot = document.getElementById('connectionDot');
            const text = document.getElementById('connectionText');
            
            if (connected) {
                dot.classList.remove('disconnected');
                dot.classList.add('connected');
                text.textContent = 'Connected';
            } else {
                dot.classList.remove('connected');
                dot.classList.add('disconnected');
                text.textContent = 'Disconnected';
            }
        }

        // Show notification
        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'slideOutRight 0.3s ease';
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 300);
            }, 3000);
        }

        // Update server time
        function updateServerTime() {
            const now = new Date();
            document.getElementById('serverTime').textContent = now.toTimeString().split(' ')[0];
        }
// Добавить обработчик изменения цены лимита
document.addEventListener('DOMContentLoaded', () => {
    const limitPriceInput = document.getElementById('limitPrice');
    if (limitPriceInput) {
        limitPriceInput.addEventListener('input', updateLimitPriceDistance);
    }
});

 // Initialize on load
window.addEventListener('load', () => {
    // Инициализация канваса
    canvas = document.getElementById('tradingChart');
    ctx = canvas.getContext('2d');
    
    // Устанавливаем начальные размеры
    const container = canvas.parentElement;
    if (container) {
        canvas.width = container.offsetWidth;
        canvas.height = container.offsetHeight;
        chartWidth = canvas.width;
        chartHeight = canvas.height;
        
        const availableWidth = chartWidth - 60 - chartPadding;
        visibleCandles = Math.floor(availableWidth / (candleWidth + candleSpacing));
    }
    
    // Обработчик изменения размера окна с дебаунсом
    let resizeTimer;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(() => {
            const container = canvas.parentElement;
            if (container) {
                const newWidth = container.offsetWidth;
                const newHeight = container.offsetHeight;
                
                // Проверяем, действительно ли изменился размер
                if (canvas.width !== newWidth || canvas.height !== newHeight) {
                    canvas.width = newWidth;
                    canvas.height = newHeight;
                    chartWidth = canvas.width;
                    chartHeight = canvas.height;
                    
                    const availableWidth = chartWidth - 60 - chartPadding;
                    visibleCandles = Math.floor(availableWidth / (candleWidth + candleSpacing));
                    
                    if (chartData && chartData.length > 0) {
                        calculatePriceRange();
                        drawChart();
                    }
                }
            }
        }, 150); // Задержка 150мс для стабильности
    });
    
    // Load saved theme
    const savedTheme = localStorage.getItem('currentTheme') || 'cyberpunk';
    if (savedTheme && themes[savedTheme]) {
        const theme = themes[savedTheme];
        const root = document.documentElement;
        for (const [key, value] of Object.entries(theme)) {
            root.style.setProperty(key, value);
        }
        currentTheme = savedTheme;
        document.body.className = 'theme-' + savedTheme;
        
        // Set active theme button
        document.querySelectorAll('.theme-option').forEach(btn => {
            if (btn.textContent.toLowerCase() === savedTheme) {
                btn.classList.add('active');
                btn.style.border = '2px solid var(--accent-primary)';
            }
        });
    }
    
   // Initialize chart event listeners
    initChart();
    
    // Load demo data initially
    chartData = generateDemoCandles();
    calculatePriceRange();
    drawChart();
    
    // Initialize WebSocket
    initWebSocket();
    
    // Start server time update
    setInterval(updateServerTime, 1000);
    
    // Start animation for price line
    setInterval(() => {
        if (document.getElementById('showPriceLine').checked) {
            drawChart();
        }
    }, 1000);
    
    // Initialize panel resize functionality
    if (typeof initPanelResize === 'function') {
        initPanelResize();
    }
    
    // Обработка клавиш Delete и ESC
document.addEventListener('keydown', (e) => {
    if (e.key === 'Delete' && hoveredDrawing !== null) {
        drawings.splice(hoveredDrawing, 1);
        hoveredDrawing = null;
        drawChart();
        return;
    }
    
    if (e.key === 'Escape') {
        // Закрываем историю если открыта
        const historyModal = document.getElementById('historyModal');
        if (historyModal && historyModal.style.display === 'block') {
            closeHistory();
            return;
        }
        
        if (pendingOrderMode || pendingOrderPreview) {
            cancelPendingOrderMode();
            showNotification('Order placement cancelled', 'info');
        }
    }
});
    
    updatePendingOrders([]);
});

// Функции для модального окна истории (ВЫНЕСЕНЫ ЗА ПРЕДЕЛЫ window.addEventListener)
function openHistory() {
    const modal = document.getElementById('historyModal');
    const iframe = document.getElementById('historyFrame');
    
    if (!iframe.src) {
        iframe.src = window.location.origin + '/history';
    }
    
    modal.style.display = 'block';
}

function closeHistory() {
    const modal = document.getElementById('historyModal');
    modal.style.display = 'none';
}
// BPFX Settings - ждем загрузки страницы
document.addEventListener('DOMContentLoaded', function() {
    
    // Проверяем существование элементов
    if (document.getElementById('bpfxSensitivity')) {
        document.getElementById('bpfxSensitivity').addEventListener('input', function(e) {
            document.getElementById('bpfxSensitivityValue').textContent = e.target.value;
        });
    }
    
    if (document.getElementById('bpfxChannelWidth')) {
        document.getElementById('bpfxChannelWidth').addEventListener('input', function(e) {
            document.getElementById('bpfxChannelWidthValue').textContent = e.target.value;
        });
    }
    
    if (document.getElementById('bpfxLookback')) {
        document.getElementById('bpfxLookback').addEventListener('input', function(e) {
            document.getElementById('bpfxLookbackValue').textContent = e.target.value;
        });
    }
    
    if (document.getElementById('bpfxSLPoints')) {
        document.getElementById('bpfxSLPoints').addEventListener('input', function(e) {
            document.getElementById('bpfxSLPointsValue').textContent = e.target.value;
        });
    }
    
    if (document.getElementById('bpfxTP1')) {
        document.getElementById('bpfxTP1').addEventListener('input', function(e) {
            document.getElementById('bpfxTP1Value').textContent = parseFloat(e.target.value).toFixed(1);
        });
    }
    
    if (document.getElementById('bpfxTP2')) {
        document.getElementById('bpfxTP2').addEventListener('input', function(e) {
            document.getElementById('bpfxTP2Value').textContent = parseFloat(e.target.value).toFixed(1);
        });
    }
    
    if (document.getElementById('bpfxTP3')) {
        document.getElementById('bpfxTP3').addEventListener('input', function(e) {
            document.getElementById('bpfxTP3Value').textContent = parseFloat(e.target.value).toFixed(1);
        });
    }
});

// Функции оставляем вне DOMContentLoaded
function applyBPFXSettings() {
    const settings = {
        sensitivity: parseInt(document.getElementById('bpfxSensitivity').value),
        channelWidth: parseFloat(document.getElementById('bpfxChannelWidth').value),
        lookback: parseInt(document.getElementById('bpfxLookback').value),
        glowEffect: document.getElementById('bpfxGlowEffect').checked,
        showSignals: document.getElementById('bpfxShowSignals').checked,
        channelFill: document.getElementById('bpfxChannelFill').checked,
        showTPSL: document.getElementById('bpfxShowTPSL').checked,
        slPoints: parseInt(document.getElementById('bpfxSLPoints').value),
        tp1Ratio: parseFloat(document.getElementById('bpfxTP1').value),
        tp2Ratio: parseFloat(document.getElementById('bpfxTP2').value),
        tp3Ratio: parseFloat(document.getElementById('bpfxTP3').value)
    };
    
    const indicatorFrame = document.getElementById('indicator-bpfx');
    if (indicatorFrame && indicatorFrame.contentWindow) {
        indicatorFrame.contentWindow.postMessage({
            type: 'updateSettings',
            settings: settings
        }, '*');
    }
    
    localStorage.setItem('bpfxSettings', JSON.stringify(settings));
    
    document.getElementById('bpfxSettingsModal').style.display = 'none';
    showNotification('BPFX settings applied', 'success');
}

function resetBPFXSettings() {
    document.getElementById('bpfxSensitivity').value = 50;
    document.getElementById('bpfxSensitivityValue').textContent = 50;
    document.getElementById('bpfxChannelWidth').value = 2.5;
    document.getElementById('bpfxChannelWidthValue').textContent = 2.5;
    document.getElementById('bpfxLookback').value = 100;
    document.getElementById('bpfxLookbackValue').textContent = 100;
    document.getElementById('bpfxSLPoints').value = 20;
    document.getElementById('bpfxSLPointsValue').textContent = 20;
    document.getElementById('bpfxTP1').value = 1;
    document.getElementById('bpfxTP1Value').textContent = '1.0';
    document.getElementById('bpfxTP2').value = 2;
    document.getElementById('bpfxTP2Value').textContent = '2.0';
    document.getElementById('bpfxTP3').value = 3;
    document.getElementById('bpfxTP3Value').textContent = '3.0';
    document.getElementById('bpfxGlowEffect').checked = true;
    document.getElementById('bpfxShowSignals').checked = true;
    document.getElementById('bpfxChannelFill').checked = true;
    document.getElementById('bpfxShowTPSL').checked = true;
}
</script>
<!-- History Modal -->
<div id="historyModal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: var(--bg-primary); z-index: 3000; display: none;">
    <div style="position: absolute; top: 0; left: 0; right: 0; height: 60px; background: var(--bg-panel); border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; padding: 0 30px;">
        <div style="font-size: 20px; font-weight: bold; color: var(--accent-primary);">Trading History</div>
        <button onclick="closeHistory()" style="width: 40px; height: 40px; background: rgba(239, 68, 68, 0.1); border: 1px solid var(--danger); color: var(--danger); border-radius: 8px; cursor: pointer; font-size: 20px;">✕</button>
    </div>
    <iframe id="historyFrame" style="position: absolute; top: 60px; left: 0; width: 100%; height: calc(100% - 60px); border: none;"></iframe>
</div>
<!-- BPFX Settings Modal -->
<div class="bpfx-settings-modal" id="bpfxSettingsModal" style="
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 450px;
    max-height: 80vh;
    background: var(--bg-panel);
    border: 2px solid var(--accent-primary);
    border-radius: 20px;
    padding: 25px;
    z-index: 10001;
    display: none;
    box-shadow: 0 25px 50px rgba(0, 0, 0, 0.7), 0 0 60px rgba(0, 255, 255, 0.3);
    overflow-y: auto;
">
    <!-- Header -->
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 25px; padding-bottom: 15px; border-bottom: 2px solid var(--accent-tertiary);">
        <h3 style="color: var(--accent-primary); font-size: 18px; font-weight: bold;"> BPFX Neural Configuration</h3>
        <button onclick="document.getElementById('bpfxSettingsModal').style.display='none'" 
                style="background: var(--danger); color: white; border: none; 
                       width: 30px; height: 30px; border-radius: 50%; cursor: pointer; font-size: 16px;">✕</button>
    </div>
    
    <!-- CHANNEL SETTINGS -->
    <div style="margin-bottom: 25px;">
        <h4 style="color: var(--accent-primary); margin-bottom: 15px; font-size: 14px;"> CHANNEL SETTINGS</h4>
        
        <div style="padding: 15px; background: var(--bg-secondary); border-radius: 10px; margin-bottom: 10px;">
            <label style="color: var(--text-secondary); font-size: 12px;">Neural Sensitivity</label>
            <input type="range" id="bpfxSensitivity" min="1" max="100" value="50" style="width: 100%; margin: 10px 0;">
            <div style="text-align: right; color: var(--accent-primary);">Value: <span id="bpfxSensitivityValue">50</span></div>
        </div>
        
        <div style="padding: 15px; background: var(--bg-secondary); border-radius: 10px; margin-bottom: 10px;">
            <label style="color: var(--text-secondary); font-size: 12px;">Channel Width</label>
            <input type="range" id="bpfxChannelWidth" min="0.5" max="5" step="0.1" value="2.5" style="width: 100%; margin: 10px 0;">
            <div style="text-align: right; color: var(--accent-primary);">Value: <span id="bpfxChannelWidthValue">2.5</span></div>
        </div>
        
        <div style="padding: 15px; background: var(--bg-secondary); border-radius: 10px;">
            <label style="color: var(--text-secondary); font-size: 12px;">Lookback Period</label>
            <input type="range" id="bpfxLookback" min="10" max="500" value="100" style="width: 100%; margin: 10px 0;">
            <div style="text-align: right; color: var(--accent-primary);">Value: <span id="bpfxLookbackValue">100</span></div>
        </div>
    </div>
    
    <!-- VISUAL SETTINGS -->
    <div style="margin-bottom: 25px;">
        <h4 style="color: var(--accent-primary); margin-bottom: 15px; font-size: 14px;"> VISUAL SETTINGS</h4>
        
        <div style="padding: 15px; background: var(--bg-secondary); border-radius: 10px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <label style="color: var(--text-secondary); font-size: 12px;">Glow Effect</label>
                <label class="toggle-switch">
                    <input type="checkbox" id="bpfxGlowEffect" checked>
                    <span class="toggle-slider"></span>
                </label>
            </div>
            
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <label style="color: var(--text-secondary); font-size: 12px;">Show Buy/Sell Signals</label>
                <label class="toggle-switch">
                    <input type="checkbox" id="bpfxShowSignals" checked>
                    <span class="toggle-slider"></span>
                </label>
            </div>
            
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <label style="color: var(--text-secondary); font-size: 12px;">Channel Fill</label>
                <label class="toggle-switch">
                    <input type="checkbox" id="bpfxChannelFill" checked>
                    <span class="toggle-slider"></span>
                </label>
            </div>
            
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <label style="color: var(--text-secondary); font-size: 12px;">Show TP/SL Levels</label>
                <label class="toggle-switch">
                    <input type="checkbox" id="bpfxShowTPSL" checked>
                    <span class="toggle-slider"></span>
                </label>
            </div>
        </div>
    </div>
    
    <!-- RISK MANAGEMENT -->
    <div style="margin-bottom: 25px;">
        <h4 style="color: var(--accent-primary); margin-bottom: 15px; font-size: 14px;"> RISK MANAGEMENT</h4>
        
        <div style="padding: 15px; background: var(--bg-secondary); border-radius: 10px; margin-bottom: 10px;">
            <label style="color: var(--text-secondary); font-size: 12px;">Stop Loss (Points)</label>
            <input type="range" id="bpfxSLPoints" min="5" max="100" value="20" style="width: 100%; margin: 10px 0;">
            <div style="text-align: right; color: var(--danger);">SL: <span id="bpfxSLPointsValue">20</span> points</div>
        </div>
        
        <div style="padding: 15px; background: var(--bg-secondary); border-radius: 10px; margin-bottom: 10px;">
            <label style="color: var(--text-secondary); font-size: 12px;">TP1 Ratio</label>
            <input type="range" id="bpfxTP1" min="0.5" max="5" step="0.1" value="1" style="width: 100%; margin: 10px 0;">
            <div style="text-align: right; color: var(--success);">TP1: <span id="bpfxTP1Value">1.0</span>x</div>
        </div>
        
        <div style="padding: 15px; background: var(--bg-secondary); border-radius: 10px; margin-bottom: 10px;">
            <label style="color: var(--text-secondary); font-size: 12px;">TP2 Ratio</label>
            <input type="range" id="bpfxTP2" min="1" max="10" step="0.1" value="2" style="width: 100%; margin: 10px 0;">
            <div style="text-align: right; color: var(--success);">TP2: <span id="bpfxTP2Value">2.0</span>x</div>
        </div>
        
        <div style="padding: 15px; background: var(--bg-secondary); border-radius: 10px;">
            <label style="color: var(--text-secondary); font-size: 12px;">TP3 Ratio</label>
            <input type="range" id="bpfxTP3" min="2" max="15" step="0.1" value="3" style="width: 100%; margin: 10px 0;">
            <div style="text-align: right; color: var(--success);">TP3: <span id="bpfxTP3Value">3.0</span>x</div>
        </div>
    </div>
    
    <!-- Buttons -->
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
        <button onclick="resetBPFXSettings()" style="
            padding: 12px;
            background: var(--bg-secondary);
            border: 1px solid var(--danger);
            border-radius: 10px;
            color: var(--danger);
            cursor: pointer;
        ">Reset</button>
        
        <button onclick="applyBPFXSettings()" style="
            padding: 12px;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            border: none;
            border-radius: 10px;
            color: white;
            font-weight: bold;
            cursor: pointer;
        ">Apply Settings</button>
    </div>
</div>
</body>
</html>